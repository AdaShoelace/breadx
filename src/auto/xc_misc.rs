// This file was automatically generated by the flutterbug_generator crate from "/home/jtnunley/Programming/Projects/exbound/xml/xc_misc.xml".
// This file is considered to be dual-licensed under the MIT and Apache 2.0 licenses.

use super::prelude::*;
#[derive(Default, Debug, Clone)]
pub struct GetVersionRequest {
    pub client_major_version: Card16,
    pub client_minor_version: Card16,
}
impl AsByteSequence for GetVersionRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.client_major_version.as_bytes(&mut bytes[index..]);
        index += self.client_minor_version.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        log::trace!("Deserializing GetVersionRequest from bytes");
        let (client_major_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (client_minor_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                client_major_version,
                client_minor_version,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetVersionReply {
    pub sequence: Card16,
    pub length: Card32,
    pub server_major_version: Card16,
    pub server_minor_version: Card16,
}
impl AsByteSequence for GetVersionReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.server_major_version.as_bytes(&mut bytes[index..]);
        index += self.server_minor_version.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        log::trace!("Deserializing GetVersionReply from bytes");
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (server_major_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (server_minor_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                server_major_version,
                server_minor_version,
            },
            index,
        ))
    }
}
impl Request for GetVersionRequest {
    type Reply = GetVersionReply;
    #[inline]
    fn opcode(&self) -> Byte {
        0
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetXIDRangeRequest;
impl AsByteSequence for GetXIDRangeRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetXIDRangeReply {
    pub sequence: Card16,
    pub length: Card32,
    pub start_id: Card32,
    pub count: Card32,
}
impl AsByteSequence for GetXIDRangeReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Card32>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.start_id.as_bytes(&mut bytes[index..]);
        index += self.count.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        log::trace!("Deserializing GetXIDRangeReply from bytes");
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (start_id, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (count, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                start_id,
                count,
            },
            index,
        ))
    }
}
impl Request for GetXIDRangeRequest {
    type Reply = GetXIDRangeReply;
    #[inline]
    fn opcode(&self) -> Byte {
        1
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetXIDListRequest {
    pub count: Card32,
}
impl AsByteSequence for GetXIDListRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.count.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        log::trace!("Deserializing GetXIDListRequest from bytes");
        let (count, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { count }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetXIDListReply {
    pub sequence: Card16,
    pub length: Card32,
    pub ids: Vec<Card32>,
}
impl AsByteSequence for GetXIDListReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size() * 32 + 20 + 4 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.ids.len() as Card32).as_bytes(&mut bytes[index..]);
        index += 20;
        index += vector_as_bytes(&self.ids, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        log::trace!("Deserializing GetXIDListReply from bytes");
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len1030947250, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 20;
        let (ids, sz): (Vec<Card32>, usize) = vector_from_bytes(bytes, len1030947250 as usize)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                ids,
            },
            index,
        ))
    }
}
impl Request for GetXIDListRequest {
    type Reply = GetXIDListReply;
    #[inline]
    fn opcode(&self) -> Byte {
        2
    }
}
