// This file was automatically generated by the flutterbug_generator crate from "/home/jtnunley/Programming/Projects/exbound/xml/xproto.xml".
// This file is considered to be dual-licensed under the MIT and Apache 2.0 licenses.

use super::prelude::*;
#[derive(Default, Debug, Clone)]
pub struct Char2b {
    pub byteOne: Card8,
    pub byteTwo: Card8,
}
impl AsByteSequence for Char2b {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.byteOne.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.byteTwo.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let byteOne: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let byteTwo: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self { byteOne, byteTwo })
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Window {
    inner: XID,
}
impl XidType for Window {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Window {
        Window { inner: xid }
    }
}
impl Default for Window {
    #[inline]
    fn default() -> Window {
        Window { inner: 0 }
    }
}
impl Window {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Window {
        Window { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Pixmap {
    inner: XID,
}
impl XidType for Pixmap {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Pixmap {
        Pixmap { inner: xid }
    }
}
impl Default for Pixmap {
    #[inline]
    fn default() -> Pixmap {
        Pixmap { inner: 0 }
    }
}
impl Pixmap {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Pixmap {
        Pixmap { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Cursor {
    inner: XID,
}
impl XidType for Cursor {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Cursor {
        Cursor { inner: xid }
    }
}
impl Default for Cursor {
    #[inline]
    fn default() -> Cursor {
        Cursor { inner: 0 }
    }
}
impl Cursor {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Cursor {
        Cursor { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Font {
    inner: XID,
}
impl XidType for Font {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Font {
        Font { inner: xid }
    }
}
impl Default for Font {
    #[inline]
    fn default() -> Font {
        Font { inner: 0 }
    }
}
impl Font {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Font {
        Font { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Gcontext {
    inner: XID,
}
impl XidType for Gcontext {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Gcontext {
        Gcontext { inner: xid }
    }
}
impl Default for Gcontext {
    #[inline]
    fn default() -> Gcontext {
        Gcontext { inner: 0 }
    }
}
impl Gcontext {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Gcontext {
        Gcontext { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Colormap {
    inner: XID,
}
impl XidType for Colormap {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Colormap {
        Colormap { inner: xid }
    }
}
impl Default for Colormap {
    #[inline]
    fn default() -> Colormap {
        Colormap { inner: 0 }
    }
}
impl Colormap {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Colormap {
        Colormap { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Atom {
    inner: XID,
}
impl XidType for Atom {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Atom {
        Atom { inner: xid }
    }
}
impl Default for Atom {
    #[inline]
    fn default() -> Atom {
        Atom { inner: 0 }
    }
}
impl Atom {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Atom {
        Atom { inner: 0 }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
pub enum Drawable {
    Window(Window),
    Pixmap(Pixmap),
}
impl XidType for Drawable {
    #[inline]
    fn xid(&self) -> XID {
        match self {
            Self::Window(i) => i.xid(),
            Self::Pixmap(i) => i.xid(),
        }
    }
    #[inline]
    fn from_xid(xid: XID) -> Self {
        Self::Window(Window::from_xid(xid))
    }
}
impl Default for Drawable {
    #[inline]
    fn default() -> Drawable {
        Drawable::Window(Default::default())
    }
}
#[derive(Debug, Copy, Clone, Hash)]
pub enum Fontable {
    Font(Font),
    Gcontext(Gcontext),
}
impl XidType for Fontable {
    #[inline]
    fn xid(&self) -> XID {
        match self {
            Self::Font(i) => i.xid(),
            Self::Gcontext(i) => i.xid(),
        }
    }
    #[inline]
    fn from_xid(xid: XID) -> Self {
        Self::Font(Font::from_xid(xid))
    }
}
impl Default for Fontable {
    #[inline]
    fn default() -> Fontable {
        Fontable::Font(Default::default())
    }
}
pub type Visualid = Card32;
pub type Timestamp = Card32;
pub type Keysym = Card32;
pub type Keycode = Card8;
pub type Button = Card8;
#[derive(Default, Debug, Clone)]
pub struct Point {
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for Point {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self { x, y })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Rectangle {
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for Rectangle {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            x,
            y,
            width,
            height,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Arc {
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub angleOne: Int16,
    pub angleTwo: Int16,
}
impl AsByteSequence for Arc {
    #[inline]
    fn size() -> usize {
        <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.angleOne.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.angleTwo.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let angleOne: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let angleTwo: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            x,
            y,
            width,
            height,
            angleOne,
            angleTwo,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Format {
    pub depth: Card8,
    pub bits_per_pixel: Card8,
    pub scanline_pad: Card8,
}
impl AsByteSequence for Format {
    #[inline]
    fn size() -> usize {
        5 + <Card8>::size() + <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bits_per_pixel.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.scanline_pad.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 5;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bits_per_pixel: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let scanline_pad: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 5;
        Some(Self {
            depth,
            bits_per_pixel,
            scanline_pad,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Visualtype {
    pub visual_id: Visualid,
    pub class: Card8,
    pub bits_per_rgb_value: Card8,
    pub colormap_entries: Card16,
    pub red_mask: Card32,
    pub green_mask: Card32,
    pub blue_mask: Card32,
}
impl AsByteSequence for Visualtype {
    #[inline]
    fn size() -> usize {
        4 + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card16>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Visualid>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.visual_id.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
        self.class.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bits_per_rgb_value.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.colormap_entries.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.red_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.green_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.blue_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        index += 4;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let visual_id: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        let class: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bits_per_rgb_value: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let colormap_entries: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let red_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let green_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let blue_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        index += 4;
        Some(Self {
            visual_id,
            class,
            bits_per_rgb_value,
            colormap_entries,
            red_mask,
            green_mask,
            blue_mask,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Depth {
    pub depth: Card8,
    pub visuals: Vec<Visualtype>,
}
impl AsByteSequence for Depth {
    #[inline]
    fn size() -> usize {
        <*mut Visualtype>::size() + 4 + 2 + 1 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        (self.visuals.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 4;
        self.visuals.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Visualtype>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let len169782830: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 4;
        let visuals: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Visualtype>::size();
        let visuals: Vec<Visualtype> = unsafe { clone_from_ptr(visuals, len169782830) };
        Some(Self { depth, visuals })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Screen {
    pub root: Window,
    pub default_colormap: Colormap,
    pub white_pixel: Card32,
    pub black_pixel: Card32,
    pub current_input_masks: Card32,
    pub width_in_pixels: Card16,
    pub height_in_pixels: Card16,
    pub width_in_millimeters: Card16,
    pub height_in_millimeters: Card16,
    pub min_installed_maps: Card16,
    pub max_installed_maps: Card16,
    pub root_visual: Visualid,
    pub backing_stores: Byte,
    pub save_unders: ::std::os::raw::c_char,
    pub root_depth: Card8,
    pub allowed_depths: Vec<Depth>,
}
impl AsByteSequence for Screen {
    #[inline]
    fn size() -> usize {
        <*mut Depth>::size()
            + 2
            + <Card8>::size()
            + <::std::os::raw::c_char>::size()
            + <Byte>::size()
            + <Visualid>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Colormap>::size()
            + <Window>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.default_colormap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.white_pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.black_pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.current_input_masks.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.width_in_pixels.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height_in_pixels.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.width_in_millimeters.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height_in_millimeters.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.min_installed_maps.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.max_installed_maps.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.root_visual.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
        self.backing_stores.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.save_unders.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.root_depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        (self.allowed_depths.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.allowed_depths.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Depth>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let default_colormap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let white_pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let black_pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let current_input_masks: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let width_in_pixels: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height_in_pixels: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let width_in_millimeters: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height_in_millimeters: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let min_installed_maps: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let max_installed_maps: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let root_visual: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        let backing_stores: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let save_unders: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let root_depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let len3207970609: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let allowed_depths: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Depth>::size();
        let allowed_depths: Vec<Depth> = unsafe { clone_from_ptr(allowed_depths, len3207970609) };
        Some(Self {
            root,
            default_colormap,
            white_pixel,
            black_pixel,
            current_input_masks,
            width_in_pixels,
            height_in_pixels,
            width_in_millimeters,
            height_in_millimeters,
            min_installed_maps,
            max_installed_maps,
            root_visual,
            backing_stores,
            save_unders,
            root_depth,
            allowed_depths,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupRequest {
    pub byte_order: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub authorization_protocol_name: String,
    pub authorization_protocol_data: String,
}
impl AsByteSequence for SetupRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size()
            + <*mut bool>::size()
            + 2
            + 2
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.byte_order.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.authorization_protocol_name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        (self.authorization_protocol_data.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.authorization_protocol_name
            .as_ptr()
            .as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
        self.authorization_protocol_data
            .as_ptr()
            .as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let byte_order: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let protocol_major_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let protocol_minor_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len3906375674: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let len534413113: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let authorization_protocol_name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let authorization_protocol_name: String =
            unsafe { string_from_ptr(authorization_protocol_name, len3906375674) };
        let authorization_protocol_data: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let authorization_protocol_data: String =
            unsafe { string_from_ptr(authorization_protocol_data, len534413113) };
        Some(Self {
            byte_order,
            protocol_major_version,
            protocol_minor_version,
            authorization_protocol_name,
            authorization_protocol_data,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupFailed {
    pub status: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub length: Card16,
    pub reason: String,
}
impl AsByteSequence for SetupFailed {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 2
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        (self.reason.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.length.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.reason.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let len2591450263: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let protocol_major_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let protocol_minor_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let length: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let reason: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let reason: String = unsafe { string_from_ptr(reason, len2591450263) };
        Some(Self {
            status,
            protocol_major_version,
            protocol_minor_version,
            length,
            reason,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupAuthenticate {
    pub status: Card8,
    pub reason: String,
}
impl AsByteSequence for SetupAuthenticate {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 5 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 5;
        (self.reason.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.reason.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 5;
        let len581821202: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let reason: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let reason: String = unsafe { string_from_ptr(reason, len581821202) };
        Some(Self { status, reason })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Setup {
    pub status: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub length: Card16,
    pub release_number: Card32,
    pub resource_id_base: Card32,
    pub resource_id_mask: Card32,
    pub motion_buffer_size: Card32,
    pub maximum_request_length: Card16,
    pub image_byte_order: Card8,
    pub bitmap_format_bit_order: Card8,
    pub bitmap_format_scanline_unit: Card8,
    pub bitmap_format_scanline_pad: Card8,
    pub min_keycode: Keycode,
    pub max_keycode: Keycode,
    pub vendor: String,
    pub pixmap_formats: Vec<Format>,
    pub roots: Vec<Screen>,
}
impl AsByteSequence for Setup {
    #[inline]
    fn size() -> usize {
        <*mut Screen>::size()
            + <*mut Format>::size()
            + <*mut bool>::size()
            + 4
            + <Keycode>::size()
            + <Keycode>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card8>::size()
            + 2
            + 2
            + <Card16>::size()
            + 2
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.length.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.release_number.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.resource_id_base.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.resource_id_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.motion_buffer_size.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        (self.vendor.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.maximum_request_length.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.roots.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        (self.pixmap_formats.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.image_byte_order.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bitmap_format_bit_order.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bitmap_format_scanline_unit
            .as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bitmap_format_scanline_pad
            .as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.min_keycode.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.max_keycode.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        index += 4;
        self.vendor.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
        self.pixmap_formats.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Format>::size();
        self.roots.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Screen>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let protocol_major_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let protocol_minor_version: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let length: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let release_number: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let resource_id_base: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let resource_id_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let motion_buffer_size: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let len1385215286: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let maximum_request_length: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len145274049: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let len2673543299: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let image_byte_order: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bitmap_format_bit_order: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bitmap_format_scanline_unit: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bitmap_format_scanline_pad: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let min_keycode: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let max_keycode: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        index += 4;
        let vendor: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let vendor: String = unsafe { string_from_ptr(vendor, len1385215286) };
        let pixmap_formats: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Format>::size();
        let pixmap_formats: Vec<Format> = unsafe { clone_from_ptr(pixmap_formats, len2673543299) };
        let roots: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Screen>::size();
        let roots: Vec<Screen> = unsafe { clone_from_ptr(roots, len145274049) };
        Some(Self {
            status,
            protocol_major_version,
            protocol_minor_version,
            length,
            release_number,
            resource_id_base,
            resource_id_mask,
            motion_buffer_size,
            maximum_request_length,
            image_byte_order,
            bitmap_format_bit_order,
            bitmap_format_scanline_unit,
            bitmap_format_scanline_pad,
            min_keycode,
            max_keycode,
            vendor,
            pixmap_formats,
            roots,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateWindowRequest {
    pub depth: Card8,
    pub wid: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub class: Card16,
    pub visual: Visualid,
}
impl AsByteSequence for CreateWindowRequest {
    #[inline]
    fn size() -> usize {
        <Visualid>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.wid.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.border_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.class.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let wid: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let border_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let class: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        Some(Self {
            depth,
            wid,
            parent,
            x,
            y,
            width,
            height,
            border_width,
            class,
            visual,
        })
    }
}
impl Request for CreateWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        1
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeWindowAttributesRequest {
    pub window: Window,
}
impl AsByteSequence for ChangeWindowAttributesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for ChangeWindowAttributesRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        2
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetWindowAttributesRequest {
    pub window: Window,
}
impl AsByteSequence for GetWindowAttributesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetWindowAttributesReply {
    pub backing_store: Card8,
    pub visual: Visualid,
    pub class: Card16,
    pub bit_gravity: Card8,
    pub win_gravity: Card8,
    pub backing_planes: Card32,
    pub backing_pixel: Card32,
    pub save_under: ::std::os::raw::c_char,
    pub map_is_installed: ::std::os::raw::c_char,
    pub map_state: Card8,
    pub override_redirect: ::std::os::raw::c_char,
    pub colormap: Colormap,
    pub all_event_masks: Card32,
    pub your_event_mask: Card32,
    pub do_not_propagate_mask: Card16,
}
impl AsByteSequence for GetWindowAttributesReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Colormap>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <::std::os::raw::c_char>::size()
            + <::std::os::raw::c_char>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card16>::size()
            + <Visualid>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.backing_store.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.visual.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
        self.class.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.bit_gravity.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.win_gravity.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.backing_planes.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.backing_pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.save_under.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.map_is_installed.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.map_state.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.override_redirect.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.colormap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.all_event_masks.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.your_event_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.do_not_propagate_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let backing_store: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let visual: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        let class: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let bit_gravity: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let win_gravity: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let backing_planes: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let backing_pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let save_under: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let map_is_installed: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let map_state: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let override_redirect: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let colormap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let all_event_masks: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let your_event_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let do_not_propagate_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            backing_store,
            visual,
            class,
            bit_gravity,
            win_gravity,
            backing_planes,
            backing_pixel,
            save_under,
            map_is_installed,
            map_state,
            override_redirect,
            colormap,
            all_event_masks,
            your_event_mask,
            do_not_propagate_mask,
        })
    }
}
impl Request for GetWindowAttributesRequest {
    type Reply = GetWindowAttributesReply;
    #[inline]
    fn opcode() -> Byte {
        3
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroyWindowRequest {
    pub window: Window,
}
impl AsByteSequence for DestroyWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for DestroyWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        4
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroySubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for DestroySubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for DestroySubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        5
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeSaveSetRequest {
    pub mode: Byte,
    pub window: Window,
}
impl AsByteSequence for ChangeSaveSetRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { mode, window })
    }
}
impl Request for ChangeSaveSetRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        6
    }
}
#[derive(Default, Debug, Clone)]
pub struct ReparentWindowRequest {
    pub window: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for ReparentWindowRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            window,
            parent,
            x,
            y,
        })
    }
}
impl Request for ReparentWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        7
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapWindowRequest {
    pub window: Window,
}
impl AsByteSequence for MapWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for MapWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        8
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapSubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for MapSubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for MapSubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        9
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapWindowRequest {
    pub window: Window,
}
impl AsByteSequence for UnmapWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for UnmapWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        10
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapSubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for UnmapSubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
impl Request for UnmapSubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        11
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureWindowRequest {
    pub window: Window,
    pub value_mask: Card16,
}
impl AsByteSequence for ConfigureWindowRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.value_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let value_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self { window, value_mask })
    }
}
impl Request for ConfigureWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        12
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateWindowRequest {
    pub direction: Card8,
    pub window: Window,
}
impl AsByteSequence for CirculateWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.direction.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let direction: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { direction, window })
    }
}
impl Request for CirculateWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        13
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetGeometryRequest {
    pub drawable: Drawable,
}
impl AsByteSequence for GetGeometryRequest {
    #[inline]
    fn size() -> usize {
        <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        Some(Self { drawable })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetGeometryReply {
    pub depth: Card8,
    pub root: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
}
impl AsByteSequence for GetGeometryReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.border_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let border_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            depth,
            root,
            x,
            y,
            width,
            height,
            border_width,
        })
    }
}
impl Request for GetGeometryRequest {
    type Reply = GetGeometryReply;
    #[inline]
    fn opcode() -> Byte {
        14
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTreeRequest {
    pub window: Window,
}
impl AsByteSequence for QueryTreeRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTreeReply {
    pub root: Window,
    pub parent: Window,
    pub children: Vec<Window>,
}
impl AsByteSequence for QueryTreeReply {
    #[inline]
    fn size() -> usize {
        <*mut Window>::size() + 14 + 2 + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        (self.children.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 14;
        self.children.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let len3419262039: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 14;
        let children: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Window>::size();
        let children: Vec<Window> = unsafe { clone_from_ptr(children, len3419262039) };
        Some(Self {
            root,
            parent,
            children,
        })
    }
}
impl Request for QueryTreeRequest {
    type Reply = QueryTreeReply;
    #[inline]
    fn opcode() -> Byte {
        15
    }
}
#[derive(Default, Debug, Clone)]
pub struct InternAtomRequest {
    pub only_if_exists: ::std::os::raw::c_char,
    pub name: String,
}
impl AsByteSequence for InternAtomRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.only_if_exists.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let only_if_exists: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let len3147305911: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len3147305911) };
        Some(Self {
            only_if_exists,
            name,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct InternAtomReply {
    pub atom: Atom,
}
impl AsByteSequence for InternAtomReply {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.atom.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let atom: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self { atom })
    }
}
impl Request for InternAtomRequest {
    type Reply = InternAtomReply;
    #[inline]
    fn opcode() -> Byte {
        16
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetAtomNameRequest {
    pub atom: Atom,
}
impl AsByteSequence for GetAtomNameRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.atom.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let atom: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self { atom })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetAtomNameReply {
    pub name: String,
}
impl AsByteSequence for GetAtomNameReply {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len745474678: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len745474678) };
        Some(Self { name })
    }
}
impl Request for GetAtomNameRequest {
    type Reply = GetAtomNameReply;
    #[inline]
    fn opcode() -> Byte {
        17
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangePropertyRequest {
    pub mode: Card8,
    pub window: Window,
    pub property: Atom,
    pub type_: Atom,
    pub format: Card8,
    pub data_len: Card32,
    pub data: Vec<()>,
}
impl AsByteSequence for ChangePropertyRequest {
    #[inline]
    fn size() -> usize {
        <*mut ()>::size()
            + <Card32>::size()
            + 3
            + <Card8>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.type_.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.format.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 3;
        self.data_len.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.data.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut ()>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let type_: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let format: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 3;
        let data_len: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let data: Vec<()> = <Vec<()>>::from_bytes(&bytes[index..])?;
        index += <*mut ()>::size();
        Some(Self {
            mode,
            window,
            property,
            type_,
            format,
            data_len,
            data,
        })
    }
}
impl Request for ChangePropertyRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        18
    }
}
#[derive(Default, Debug, Clone)]
pub struct DeletePropertyRequest {
    pub window: Window,
    pub property: Atom,
}
impl AsByteSequence for DeletePropertyRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self { window, property })
    }
}
impl Request for DeletePropertyRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        19
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPropertyRequest {
    pub delete: ::std::os::raw::c_char,
    pub window: Window,
    pub property: Atom,
    pub type_: Atom,
    pub long_offset: Card32,
    pub long_length: Card32,
}
impl AsByteSequence for GetPropertyRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card32>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.delete.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.type_.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.long_offset.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.long_length.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let delete: ::std::os::raw::c_char = <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let type_: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let long_offset: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let long_length: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self {
            delete,
            window,
            property,
            type_,
            long_offset,
            long_length,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPropertyReply {
    pub format: Card8,
    pub type_: Atom,
    pub bytes_after: Card32,
    pub value_len: Card32,
    pub value: Vec<()>,
}
impl AsByteSequence for GetPropertyReply {
    #[inline]
    fn size() -> usize {
        <*mut ()>::size()
            + 12
            + <Card32>::size()
            + <Card32>::size()
            + <Atom>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.format.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.type_.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.bytes_after.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.value_len.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        index += 12;
        self.value.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut ()>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let format: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let type_: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let bytes_after: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let value_len: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        index += 12;
        let value: Vec<()> = <Vec<()>>::from_bytes(&bytes[index..])?;
        index += <*mut ()>::size();
        Some(Self {
            format,
            type_,
            bytes_after,
            value_len,
            value,
        })
    }
}
impl Request for GetPropertyRequest {
    type Reply = GetPropertyReply;
    #[inline]
    fn opcode() -> Byte {
        20
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListPropertiesRequest {
    pub window: Window,
}
impl AsByteSequence for ListPropertiesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListPropertiesReply {
    pub atoms: Vec<Atom>,
}
impl AsByteSequence for ListPropertiesReply {
    #[inline]
    fn size() -> usize {
        <*mut Atom>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.atoms.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.atoms.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len4030472288: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let atoms: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Atom>::size();
        let atoms: Vec<Atom> = unsafe { clone_from_ptr(atoms, len4030472288) };
        Some(Self { atoms })
    }
}
impl Request for ListPropertiesRequest {
    type Reply = ListPropertiesReply;
    #[inline]
    fn opcode() -> Byte {
        21
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetSelectionOwnerRequest {
    pub owner: Window,
    pub selection: Atom,
    pub time: Timestamp,
}
impl AsByteSequence for SetSelectionOwnerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.owner.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let owner: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self {
            owner,
            selection,
            time,
        })
    }
}
impl Request for SetSelectionOwnerRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        22
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetSelectionOwnerRequest {
    pub selection: Atom,
}
impl AsByteSequence for GetSelectionOwnerRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self { selection })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetSelectionOwnerReply {
    pub owner: Window,
}
impl AsByteSequence for GetSelectionOwnerReply {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.owner.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let owner: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { owner })
    }
}
impl Request for GetSelectionOwnerRequest {
    type Reply = GetSelectionOwnerReply;
    #[inline]
    fn opcode() -> Byte {
        23
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConvertSelectionRequest {
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Timestamp,
}
impl AsByteSequence for ConvertSelectionRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.requestor.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.target.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let requestor: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let target: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self {
            requestor,
            selection,
            target,
            property,
            time,
        })
    }
}
impl Request for ConvertSelectionRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        24
    }
}
#[derive(Default, Debug, Clone)]
pub struct SendEventRequest {
    pub propagate: ::std::os::raw::c_char,
    pub destination: Window,
    pub event_mask: Card32,
    pub event: [bool; 32],
}
impl AsByteSequence for SendEventRequest {
    #[inline]
    fn size() -> usize {
        <[bool; 32]>::size()
            + <Card32>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.propagate.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.destination.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.event.as_ptr().as_bytes(&mut bytes[index..]);
        index += <[bool; 32]>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let propagate: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let destination: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let event: [bool; 32] = <[bool; 32]>::from_bytes(&bytes[index..])?;
        index += <[bool; 32]>::size();
        Some(Self {
            propagate,
            destination,
            event_mask,
            event,
        })
    }
}
impl Request for SendEventRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        25
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabPointerRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub event_mask: Card16,
    pub pointer_mode: Byte,
    pub keyboard_mode: Byte,
    pub confine_to: Window,
    pub cursor: Cursor,
    pub time: Timestamp,
}
impl AsByteSequence for GrabPointerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size()
            + <Cursor>::size()
            + <Window>::size()
            + <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.owner_events.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.confine_to.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.cursor.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let owner_events: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let pointer_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let keyboard_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let confine_to: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let cursor: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self {
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            time,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabPointerReply {
    pub status: Byte,
}
impl AsByteSequence for GrabPointerReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self { status })
    }
}
impl Request for GrabPointerRequest {
    type Reply = GrabPointerReply;
    #[inline]
    fn opcode() -> Byte {
        26
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabPointerRequest {
    pub time: Timestamp,
}
impl AsByteSequence for UngrabPointerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self { time })
    }
}
impl Request for UngrabPointerRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        27
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabButtonRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub event_mask: Card16,
    pub pointer_mode: Card8,
    pub keyboard_mode: Card8,
    pub confine_to: Window,
    pub cursor: Cursor,
    pub button: Card8,
    pub modifiers: Card16,
}
impl AsByteSequence for GrabButtonRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + 1
            + <Card8>::size()
            + <Cursor>::size()
            + <Window>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.owner_events.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.confine_to.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.cursor.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.button.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        self.modifiers.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let owner_events: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let pointer_mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let keyboard_mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let confine_to: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let cursor: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let button: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let modifiers: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            owner_events,
            grab_window,
            event_mask,
            pointer_mode,
            keyboard_mode,
            confine_to,
            cursor,
            button,
            modifiers,
        })
    }
}
impl Request for GrabButtonRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        28
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabButtonRequest {
    pub button: Card8,
    pub grab_window: Window,
    pub modifiers: Card16,
}
impl AsByteSequence for UngrabButtonRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.button.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.modifiers.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let button: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let modifiers: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            button,
            grab_window,
            modifiers,
        })
    }
}
impl Request for UngrabButtonRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        29
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeActivePointerGrabRequest {
    pub cursor: Cursor,
    pub time: Timestamp,
    pub event_mask: Card16,
}
impl AsByteSequence for ChangeActivePointerGrabRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Timestamp>::size() + <Cursor>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cursor.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.event_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cursor: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let event_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            cursor,
            time,
            event_mask,
        })
    }
}
impl Request for ChangeActivePointerGrabRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        30
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyboardRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub time: Timestamp,
    pub pointer_mode: Byte,
    pub keyboard_mode: Byte,
}
impl AsByteSequence for GrabKeyboardRequest {
    #[inline]
    fn size() -> usize {
        2 + <Byte>::size()
            + <Byte>::size()
            + <Timestamp>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.owner_events.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let owner_events: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let pointer_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let keyboard_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 2;
        Some(Self {
            owner_events,
            grab_window,
            time,
            pointer_mode,
            keyboard_mode,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyboardReply {
    pub status: Byte,
}
impl AsByteSequence for GrabKeyboardReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self { status })
    }
}
impl Request for GrabKeyboardRequest {
    type Reply = GrabKeyboardReply;
    #[inline]
    fn opcode() -> Byte {
        31
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabKeyboardRequest {
    pub time: Timestamp,
}
impl AsByteSequence for UngrabKeyboardRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self { time })
    }
}
impl Request for UngrabKeyboardRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        32
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub modifiers: Card16,
    pub key: Keycode,
    pub pointer_mode: Card8,
    pub keyboard_mode: Card8,
}
impl AsByteSequence for GrabKeyRequest {
    #[inline]
    fn size() -> usize {
        3 + <Card8>::size()
            + <Card8>::size()
            + <Keycode>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.owner_events.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.modifiers.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.key.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let owner_events: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let modifiers: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let key: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let pointer_mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let keyboard_mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 3;
        Some(Self {
            owner_events,
            grab_window,
            modifiers,
            key,
            pointer_mode,
            keyboard_mode,
        })
    }
}
impl Request for GrabKeyRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        33
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabKeyRequest {
    pub key: Keycode,
    pub grab_window: Window,
    pub modifiers: Card16,
}
impl AsByteSequence for UngrabKeyRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.key.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.grab_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.modifiers.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let key: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let grab_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let modifiers: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            key,
            grab_window,
            modifiers,
        })
    }
}
impl Request for UngrabKeyRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        34
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllowEventsRequest {
    pub mode: Card8,
    pub time: Timestamp,
}
impl AsByteSequence for AllowEventsRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self { mode, time })
    }
}
impl Request for AllowEventsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        35
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabServerRequest;
impl AsByteSequence for GrabServerRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
impl Request for GrabServerRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        36
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabServerRequest;
impl AsByteSequence for UngrabServerRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
impl Request for UngrabServerRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        37
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryPointerRequest {
    pub window: Window,
}
impl AsByteSequence for QueryPointerRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryPointerReply {
    pub same_screen: ::std::os::raw::c_char,
    pub root: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub win_x: Int16,
    pub win_y: Int16,
    pub mask: Card16,
}
impl AsByteSequence for QueryPointerReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.win_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.win_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let win_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let win_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            same_screen,
            root,
            child,
            root_x,
            root_y,
            win_x,
            win_y,
            mask,
        })
    }
}
impl Request for QueryPointerRequest {
    type Reply = QueryPointerReply;
    #[inline]
    fn opcode() -> Byte {
        38
    }
}
#[derive(Default, Debug, Clone)]
pub struct Timecoord {
    pub time: Timestamp,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for Timecoord {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Timestamp>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self { time, x, y })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetMotionEventsRequest {
    pub window: Window,
    pub start: Timestamp,
    pub stop: Timestamp,
}
impl AsByteSequence for GetMotionEventsRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Timestamp>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.start.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.stop.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let start: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let stop: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self {
            window,
            start,
            stop,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetMotionEventsReply {
    pub events: Vec<Timecoord>,
}
impl AsByteSequence for GetMotionEventsReply {
    #[inline]
    fn size() -> usize {
        <*mut Timecoord>::size() + 20 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.events.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 20;
        self.events.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Timecoord>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len435956747: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 20;
        let events: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Timecoord>::size();
        let events: Vec<Timecoord> = unsafe { clone_from_ptr(events, len435956747) };
        Some(Self { events })
    }
}
impl Request for GetMotionEventsRequest {
    type Reply = GetMotionEventsReply;
    #[inline]
    fn opcode() -> Byte {
        39
    }
}
#[derive(Default, Debug, Clone)]
pub struct TranslateCoordinatesRequest {
    pub src_window: Window,
    pub dst_window: Window,
    pub src_x: Int16,
    pub src_y: Int16,
}
impl AsByteSequence for TranslateCoordinatesRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.src_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.dst_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.src_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.src_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let src_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let dst_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let src_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let src_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            src_window,
            dst_window,
            src_x,
            src_y,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct TranslateCoordinatesReply {
    pub same_screen: ::std::os::raw::c_char,
    pub child: Window,
    pub dst_x: Int16,
    pub dst_y: Int16,
}
impl AsByteSequence for TranslateCoordinatesReply {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.dst_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let dst_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            same_screen,
            child,
            dst_x,
            dst_y,
        })
    }
}
impl Request for TranslateCoordinatesRequest {
    type Reply = TranslateCoordinatesReply;
    #[inline]
    fn opcode() -> Byte {
        40
    }
}
#[derive(Default, Debug, Clone)]
pub struct WarpPointerRequest {
    pub src_window: Window,
    pub dst_window: Window,
    pub src_x: Int16,
    pub src_y: Int16,
    pub src_width: Card16,
    pub src_height: Card16,
    pub dst_x: Int16,
    pub dst_y: Int16,
}
impl AsByteSequence for WarpPointerRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.src_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.dst_window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.src_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.src_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.src_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.src_height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.dst_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let src_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let dst_window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let src_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let src_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let src_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let src_height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let dst_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            src_window,
            dst_window,
            src_x,
            src_y,
            src_width,
            src_height,
            dst_x,
            dst_y,
        })
    }
}
impl Request for WarpPointerRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        41
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetInputFocusRequest {
    pub revert_to: Card8,
    pub focus: Window,
    pub time: Timestamp,
}
impl AsByteSequence for SetInputFocusRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.revert_to.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.focus.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let revert_to: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let focus: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        Some(Self {
            revert_to,
            focus,
            time,
        })
    }
}
impl Request for SetInputFocusRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        42
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetInputFocusRequest;
impl AsByteSequence for GetInputFocusRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetInputFocusReply {
    pub revert_to: Card8,
    pub focus: Window,
}
impl AsByteSequence for GetInputFocusReply {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.revert_to.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.focus.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let revert_to: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let focus: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { revert_to, focus })
    }
}
impl Request for GetInputFocusRequest {
    type Reply = GetInputFocusReply;
    #[inline]
    fn opcode() -> Byte {
        43
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryKeymapRequest;
impl AsByteSequence for QueryKeymapRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryKeymapReply {
    pub keys: [Card8; 32],
}
impl AsByteSequence for QueryKeymapReply {
    #[inline]
    fn size() -> usize {
        <[Card8; 32]>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.keys.as_ptr().as_bytes(&mut bytes[index..]);
        index += <[Card8; 32]>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let keys: [Card8; 32] = <[Card8; 32]>::from_bytes(&bytes[index..])?;
        index += <[Card8; 32]>::size();
        Some(Self { keys })
    }
}
impl Request for QueryKeymapRequest {
    type Reply = QueryKeymapReply;
    #[inline]
    fn opcode() -> Byte {
        44
    }
}
#[derive(Default, Debug, Clone)]
pub struct OpenFontRequest {
    pub fid: Font,
    pub name: String,
}
impl AsByteSequence for OpenFontRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + <Font>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.fid.as_bytes(&mut bytes[index..]);
        index += <Font>::size();
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let fid: Font = <Font>::from_bytes(&bytes[index..])?;
        index += <Font>::size();
        let len1409096760: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len1409096760) };
        Some(Self { fid, name })
    }
}
impl Request for OpenFontRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        45
    }
}
#[derive(Default, Debug, Clone)]
pub struct CloseFontRequest {
    pub font: Font,
}
impl AsByteSequence for CloseFontRequest {
    #[inline]
    fn size() -> usize {
        <Font>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.font.as_bytes(&mut bytes[index..]);
        index += <Font>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let font: Font = <Font>::from_bytes(&bytes[index..])?;
        index += <Font>::size();
        Some(Self { font })
    }
}
impl Request for CloseFontRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        46
    }
}
#[derive(Default, Debug, Clone)]
pub struct Fontprop {
    pub name: Atom,
    pub value: Card32,
}
impl AsByteSequence for Fontprop {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Atom>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.name.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.value.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let name: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let value: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self { name, value })
    }
}
#[derive(Default, Debug, Clone)]
pub struct Charinfo {
    pub left_side_bearing: Int16,
    pub right_side_bearing: Int16,
    pub character_width: Int16,
    pub ascent: Int16,
    pub descent: Int16,
    pub attributes: Card16,
}
impl AsByteSequence for Charinfo {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.left_side_bearing.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.right_side_bearing.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.character_width.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.ascent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.descent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.attributes.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let left_side_bearing: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let right_side_bearing: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let character_width: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let ascent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let descent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let attributes: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            left_side_bearing,
            right_side_bearing,
            character_width,
            ascent,
            descent,
            attributes,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryFontRequest {
    pub font: Fontable,
}
impl AsByteSequence for QueryFontRequest {
    #[inline]
    fn size() -> usize {
        <Fontable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.font.as_bytes(&mut bytes[index..]);
        index += <Fontable>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let font: Fontable = <Fontable>::from_bytes(&bytes[index..])?;
        index += <Fontable>::size();
        Some(Self { font })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryFontReply {
    pub min_bounds: Charinfo,
    pub max_bounds: Charinfo,
    pub min_char_or_byteTwo: Card16,
    pub max_char_or_byteTwo: Card16,
    pub default_char: Card16,
    pub draw_direction: Byte,
    pub min_byteOne: Card8,
    pub max_byteOne: Card8,
    pub all_chars_exist: ::std::os::raw::c_char,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub properties: Vec<Fontprop>,
    pub char_infos: Vec<Charinfo>,
}
impl AsByteSequence for QueryFontReply {
    #[inline]
    fn size() -> usize {
        <*mut Charinfo>::size()
            + <*mut Fontprop>::size()
            + 2
            + <Int16>::size()
            + <Int16>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Byte>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 4
            + <Charinfo>::size()
            + 4
            + <Charinfo>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.min_bounds.as_bytes(&mut bytes[index..]);
        index += <Charinfo>::size();
        index += 4;
        self.max_bounds.as_bytes(&mut bytes[index..]);
        index += <Charinfo>::size();
        index += 4;
        self.min_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.max_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.default_char.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.properties.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.draw_direction.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.min_byteOne.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.max_byteOne.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.all_chars_exist.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.font_ascent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.font_descent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        (self.char_infos.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.properties.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Fontprop>::size();
        self.char_infos.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Charinfo>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let min_bounds: Charinfo = <Charinfo>::from_bytes(&bytes[index..])?;
        index += <Charinfo>::size();
        index += 4;
        let max_bounds: Charinfo = <Charinfo>::from_bytes(&bytes[index..])?;
        index += <Charinfo>::size();
        index += 4;
        let min_char_or_byteTwo: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let max_char_or_byteTwo: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let default_char: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len2473681681: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let draw_direction: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let min_byteOne: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let max_byteOne: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let all_chars_exist: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let font_ascent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let font_descent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let len1797861584: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let properties: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Fontprop>::size();
        let properties: Vec<Fontprop> = unsafe { clone_from_ptr(properties, len2473681681) };
        let char_infos: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Charinfo>::size();
        let char_infos: Vec<Charinfo> = unsafe { clone_from_ptr(char_infos, len1797861584) };
        Some(Self {
            min_bounds,
            max_bounds,
            min_char_or_byteTwo,
            max_char_or_byteTwo,
            default_char,
            draw_direction,
            min_byteOne,
            max_byteOne,
            all_chars_exist,
            font_ascent,
            font_descent,
            properties,
            char_infos,
        })
    }
}
impl Request for QueryFontRequest {
    type Reply = QueryFontReply;
    #[inline]
    fn opcode() -> Byte {
        47
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTextExtentsRequest {
    pub font: Fontable,
}
impl AsByteSequence for QueryTextExtentsRequest {
    #[inline]
    fn size() -> usize {
        <Fontable>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.font.as_bytes(&mut bytes[index..]);
        index += <Fontable>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let font: Fontable = <Fontable>::from_bytes(&bytes[index..])?;
        index += <Fontable>::size();
        Some(Self { font })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTextExtentsReply {
    pub draw_direction: Byte,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub overall_ascent: Int16,
    pub overall_descent: Int16,
    pub overall_width: Int32,
    pub overall_left: Int32,
    pub overall_right: Int32,
}
impl AsByteSequence for QueryTextExtentsReply {
    #[inline]
    fn size() -> usize {
        <Int32>::size()
            + <Int32>::size()
            + <Int32>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.draw_direction.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.font_ascent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.font_descent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.overall_ascent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.overall_descent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.overall_width.as_bytes(&mut bytes[index..]);
        index += <Int32>::size();
        self.overall_left.as_bytes(&mut bytes[index..]);
        index += <Int32>::size();
        self.overall_right.as_bytes(&mut bytes[index..]);
        index += <Int32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let draw_direction: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let font_ascent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let font_descent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let overall_ascent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let overall_descent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let overall_width: Int32 = <Int32>::from_bytes(&bytes[index..])?;
        index += <Int32>::size();
        let overall_left: Int32 = <Int32>::from_bytes(&bytes[index..])?;
        index += <Int32>::size();
        let overall_right: Int32 = <Int32>::from_bytes(&bytes[index..])?;
        index += <Int32>::size();
        Some(Self {
            draw_direction,
            font_ascent,
            font_descent,
            overall_ascent,
            overall_descent,
            overall_width,
            overall_left,
            overall_right,
        })
    }
}
impl Request for QueryTextExtentsRequest {
    type Reply = QueryTextExtentsReply;
    #[inline]
    fn opcode() -> Byte {
        48
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsRequest {
    pub max_names: Card16,
    pub pattern: String,
}
impl AsByteSequence for ListFontsRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.max_names.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.pattern.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.pattern.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let max_names: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len3805705117: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let pattern: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let pattern: String = unsafe { string_from_ptr(pattern, len3805705117) };
        Some(Self { max_names, pattern })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsReply {
    pub names: Vec<String>,
}
impl AsByteSequence for ListFontsReply {
    #[inline]
    fn size() -> usize {
        <*mut String>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.names.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.names.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut String>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len3747270059: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let names: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut String>::size();
        let names: Vec<String> = unsafe { clone_from_ptr(names, len3747270059) };
        Some(Self { names })
    }
}
impl Request for ListFontsRequest {
    type Reply = ListFontsReply;
    #[inline]
    fn opcode() -> Byte {
        49
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsWithInfoRequest {
    pub max_names: Card16,
    pub pattern: String,
}
impl AsByteSequence for ListFontsWithInfoRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.max_names.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.pattern.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.pattern.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let max_names: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len1643325227: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let pattern: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let pattern: String = unsafe { string_from_ptr(pattern, len1643325227) };
        Some(Self { max_names, pattern })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsWithInfoReply {
    pub min_bounds: Charinfo,
    pub max_bounds: Charinfo,
    pub min_char_or_byteTwo: Card16,
    pub max_char_or_byteTwo: Card16,
    pub default_char: Card16,
    pub draw_direction: Byte,
    pub min_byteOne: Card8,
    pub max_byteOne: Card8,
    pub all_chars_exist: ::std::os::raw::c_char,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub replies_hint: Card32,
    pub properties: Vec<Fontprop>,
    pub name: String,
}
impl AsByteSequence for ListFontsWithInfoReply {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size()
            + <*mut Fontprop>::size()
            + <Card32>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Byte>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 4
            + <Charinfo>::size()
            + 4
            + <Charinfo>::size()
            + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.min_bounds.as_bytes(&mut bytes[index..]);
        index += <Charinfo>::size();
        index += 4;
        self.max_bounds.as_bytes(&mut bytes[index..]);
        index += <Charinfo>::size();
        index += 4;
        self.min_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.max_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.default_char.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.properties.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.draw_direction.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.min_byteOne.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.max_byteOne.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.all_chars_exist.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.font_ascent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.font_descent.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.replies_hint.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.properties.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Fontprop>::size();
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len3313344720: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let min_bounds: Charinfo = <Charinfo>::from_bytes(&bytes[index..])?;
        index += <Charinfo>::size();
        index += 4;
        let max_bounds: Charinfo = <Charinfo>::from_bytes(&bytes[index..])?;
        index += <Charinfo>::size();
        index += 4;
        let min_char_or_byteTwo: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let max_char_or_byteTwo: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let default_char: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len1737132339: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let draw_direction: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let min_byteOne: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let max_byteOne: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let all_chars_exist: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let font_ascent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let font_descent: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let replies_hint: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let properties: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Fontprop>::size();
        let properties: Vec<Fontprop> = unsafe { clone_from_ptr(properties, len1737132339) };
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len3313344720) };
        Some(Self {
            min_bounds,
            max_bounds,
            min_char_or_byteTwo,
            max_char_or_byteTwo,
            default_char,
            draw_direction,
            min_byteOne,
            max_byteOne,
            all_chars_exist,
            font_ascent,
            font_descent,
            replies_hint,
            properties,
            name,
        })
    }
}
impl Request for ListFontsWithInfoRequest {
    type Reply = ListFontsWithInfoReply;
    #[inline]
    fn opcode() -> Byte {
        50
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetFontPathRequest {
    pub font: Vec<String>,
}
impl AsByteSequence for SetFontPathRequest {
    #[inline]
    fn size() -> usize {
        <*mut String>::size() + 2 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.font.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.font.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut String>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len3384704993: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let font: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut String>::size();
        let font: Vec<String> = unsafe { clone_from_ptr(font, len3384704993) };
        Some(Self { font })
    }
}
impl Request for SetFontPathRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        51
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetFontPathRequest;
impl AsByteSequence for GetFontPathRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetFontPathReply {
    pub path: Vec<String>,
}
impl AsByteSequence for GetFontPathReply {
    #[inline]
    fn size() -> usize {
        <*mut String>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.path.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.path.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut String>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len715933161: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let path: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut String>::size();
        let path: Vec<String> = unsafe { clone_from_ptr(path, len715933161) };
        Some(Self { path })
    }
}
impl Request for GetFontPathRequest {
    type Reply = GetFontPathReply;
    #[inline]
    fn opcode() -> Byte {
        52
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreatePixmapRequest {
    pub depth: Card8,
    pub pid: Pixmap,
    pub drawable: Drawable,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for CreatePixmapRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Drawable>::size()
            + <Pixmap>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.pid.as_bytes(&mut bytes[index..]);
        index += <Pixmap>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let pid: Pixmap = <Pixmap>::from_bytes(&bytes[index..])?;
        index += <Pixmap>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            depth,
            pid,
            drawable,
            width,
            height,
        })
    }
}
impl Request for CreatePixmapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        53
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreePixmapRequest {
    pub pixmap: Pixmap,
}
impl AsByteSequence for FreePixmapRequest {
    #[inline]
    fn size() -> usize {
        <Pixmap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.pixmap.as_bytes(&mut bytes[index..]);
        index += <Pixmap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let pixmap: Pixmap = <Pixmap>::from_bytes(&bytes[index..])?;
        index += <Pixmap>::size();
        Some(Self { pixmap })
    }
}
impl Request for FreePixmapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        54
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateGCRequest {
    pub cid: Gcontext,
    pub drawable: Drawable,
}
impl AsByteSequence for CreateGCRequest {
    #[inline]
    fn size() -> usize {
        <Drawable>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cid.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cid: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        Some(Self { cid, drawable })
    }
}
impl Request for CreateGCRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        55
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeGCRequest {
    pub gc: Gcontext,
}
impl AsByteSequence for ChangeGCRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { gc })
    }
}
impl Request for ChangeGCRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        56
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyGCRequest {
    pub src_gc: Gcontext,
    pub dst_gc: Gcontext,
    pub value_mask: Card32,
}
impl AsByteSequence for CopyGCRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Gcontext>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.src_gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.dst_gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.value_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let src_gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let dst_gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let value_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self {
            src_gc,
            dst_gc,
            value_mask,
        })
    }
}
impl Request for CopyGCRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        57
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetDashesRequest {
    pub gc: Gcontext,
    pub dash_offset: Card16,
    pub dashes: Vec<Card8>,
}
impl AsByteSequence for SetDashesRequest {
    #[inline]
    fn size() -> usize {
        <*mut Card8>::size() + 2 + <Card16>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.dash_offset.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        (self.dashes.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.dashes.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let dash_offset: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let len1050847085: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let dashes: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card8>::size();
        let dashes: Vec<Card8> = unsafe { clone_from_ptr(dashes, len1050847085) };
        Some(Self {
            gc,
            dash_offset,
            dashes,
        })
    }
}
impl Request for SetDashesRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        58
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetClipRectanglesRequest {
    pub ordering: Byte,
    pub gc: Gcontext,
    pub clip_x_origin: Int16,
    pub clip_y_origin: Int16,
}
impl AsByteSequence for SetClipRectanglesRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.ordering.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.clip_x_origin.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.clip_y_origin.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let ordering: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let clip_x_origin: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let clip_y_origin: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            ordering,
            gc,
            clip_x_origin,
            clip_y_origin,
        })
    }
}
impl Request for SetClipRectanglesRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        59
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeGCRequest {
    pub gc: Gcontext,
}
impl AsByteSequence for FreeGCRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { gc })
    }
}
impl Request for FreeGCRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        60
    }
}
#[derive(Default, Debug, Clone)]
pub struct ClearAreaRequest {
    pub exposures: ::std::os::raw::c_char,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for ClearAreaRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.exposures.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let exposures: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            exposures,
            window,
            x,
            y,
            width,
            height,
        })
    }
}
impl Request for ClearAreaRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        61
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyAreaRequest {
    pub src_drawable: Drawable,
    pub dst_drawable: Drawable,
    pub gc: Gcontext,
    pub src_x: Int16,
    pub src_y: Int16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for CopyAreaRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.src_drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.dst_drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.src_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.src_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let src_drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let dst_drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let src_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let src_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
        })
    }
}
impl Request for CopyAreaRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        62
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyPlaneRequest {
    pub src_drawable: Drawable,
    pub dst_drawable: Drawable,
    pub gc: Gcontext,
    pub src_x: Int16,
    pub src_y: Int16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub bit_plane: Card32,
}
impl AsByteSequence for CopyPlaneRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.src_drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.dst_drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.src_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.src_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.bit_plane.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let src_drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let dst_drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let src_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let src_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let bit_plane: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self {
            src_drawable,
            dst_drawable,
            gc,
            src_x,
            src_y,
            dst_x,
            dst_y,
            width,
            height,
            bit_plane,
        })
    }
}
impl Request for CopyPlaneRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        63
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyPointRequest {
    pub coordinate_mode: Byte,
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyPointRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let coordinate_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self {
            coordinate_mode,
            drawable,
            gc,
        })
    }
}
impl Request for PolyPointRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        64
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyLineRequest {
    pub coordinate_mode: Byte,
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyLineRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let coordinate_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self {
            coordinate_mode,
            drawable,
            gc,
        })
    }
}
impl Request for PolyLineRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        65
    }
}
#[derive(Default, Debug, Clone)]
pub struct Segment {
    pub xOne: Int16,
    pub yOne: Int16,
    pub xTwo: Int16,
    pub yTwo: Int16,
}
impl AsByteSequence for Segment {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.xOne.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.yOne.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.xTwo.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.yTwo.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let xOne: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let yOne: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let xTwo: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let yTwo: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            xOne,
            yOne,
            xTwo,
            yTwo,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolySegmentRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolySegmentRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { drawable, gc })
    }
}
impl Request for PolySegmentRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        66
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyRectangleRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyRectangleRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { drawable, gc })
    }
}
impl Request for PolyRectangleRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        67
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyArcRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyArcRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { drawable, gc })
    }
}
impl Request for PolyArcRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        68
    }
}
#[derive(Default, Debug, Clone)]
pub struct FillPolyRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub shape: Card8,
    pub coordinate_mode: Card8,
}
impl AsByteSequence for FillPolyRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card8>::size() + <Card8>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.shape.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let shape: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let coordinate_mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 2;
        Some(Self {
            drawable,
            gc,
            shape,
            coordinate_mode,
        })
    }
}
impl Request for FillPolyRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        69
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyFillRectangleRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyFillRectangleRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { drawable, gc })
    }
}
impl Request for PolyFillRectangleRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        70
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyFillArcRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyFillArcRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        Some(Self { drawable, gc })
    }
}
impl Request for PolyFillArcRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        71
    }
}
#[derive(Default, Debug, Clone)]
pub struct PutImageRequest {
    pub format: Card8,
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub width: Card16,
    pub height: Card16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub left_pad: Card8,
    pub depth: Card8,
}
impl AsByteSequence for PutImageRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card8>::size()
            + <Card8>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.format.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.dst_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.dst_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.left_pad.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let format: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let dst_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let dst_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let left_pad: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 2;
        Some(Self {
            format,
            drawable,
            gc,
            width,
            height,
            dst_x,
            dst_y,
            left_pad,
            depth,
        })
    }
}
impl Request for PutImageRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        72
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetImageRequest {
    pub format: Card8,
    pub drawable: Drawable,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub plane_mask: Card32,
}
impl AsByteSequence for GetImageRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Drawable>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.format.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.plane_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let format: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let plane_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self {
            format,
            drawable,
            x,
            y,
            width,
            height,
            plane_mask,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetImageReply {
    pub depth: Card8,
    pub visual: Visualid,
    pub data: Vec<Byte>,
}
impl AsByteSequence for GetImageReply {
    #[inline]
    fn size() -> usize {
        <*mut Byte>::size() + 20 + <Visualid>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.depth.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.visual.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
        index += 20;
        self.data.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let depth: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let visual: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        index += 20;
        Some(Self {
            depth,
            visual,
            data,
        })
    }
}
impl Request for GetImageRequest {
    type Reply = GetImageReply;
    #[inline]
    fn opcode() -> Byte {
        73
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyText8Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for PolyText8Request {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self { drawable, gc, x, y })
    }
}
impl Request for PolyText8Request {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        74
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyText16Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for PolyText16Request {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self { drawable, gc, x, y })
    }
}
impl Request for PolyText16Request {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        75
    }
}
#[derive(Default, Debug, Clone)]
pub struct ImageText8Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
    pub string: String,
}
impl AsByteSequence for ImageText8Request {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.string.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.string.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len227730711: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let string: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let string: String = unsafe { string_from_ptr(string, len227730711) };
        Some(Self {
            drawable,
            gc,
            x,
            y,
            string,
        })
    }
}
impl Request for ImageText8Request {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        76
    }
}
#[derive(Default, Debug, Clone)]
pub struct ImageText16Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
    pub string: Vec<Char2b>,
}
impl AsByteSequence for ImageText16Request {
    #[inline]
    fn size() -> usize {
        <*mut Char2b>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.string.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.gc.as_bytes(&mut bytes[index..]);
        index += <Gcontext>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.string.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Char2b>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len1206279361: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let gc: Gcontext = <Gcontext>::from_bytes(&bytes[index..])?;
        index += <Gcontext>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let string: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Char2b>::size();
        let string: Vec<Char2b> = unsafe { clone_from_ptr(string, len1206279361) };
        Some(Self {
            drawable,
            gc,
            x,
            y,
            string,
        })
    }
}
impl Request for ImageText16Request {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        77
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateColormapRequest {
    pub alloc: Byte,
    pub mid: Colormap,
    pub window: Window,
    pub visual: Visualid,
}
impl AsByteSequence for CreateColormapRequest {
    #[inline]
    fn size() -> usize {
        <Visualid>::size() + <Window>::size() + <Colormap>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.alloc.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.mid.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.visual.as_bytes(&mut bytes[index..]);
        index += <Visualid>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let alloc: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let mid: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let visual: Visualid = <Visualid>::from_bytes(&bytes[index..])?;
        index += <Visualid>::size();
        Some(Self {
            alloc,
            mid,
            window,
            visual,
        })
    }
}
impl Request for CreateColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        78
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for FreeColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { cmap })
    }
}
impl Request for FreeColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        79
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyColormapAndFreeRequest {
    pub mid: Colormap,
    pub src_cmap: Colormap,
}
impl AsByteSequence for CopyColormapAndFreeRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.mid.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.src_cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let mid: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let src_cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { mid, src_cmap })
    }
}
impl Request for CopyColormapAndFreeRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        80
    }
}
#[derive(Default, Debug, Clone)]
pub struct InstallColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for InstallColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { cmap })
    }
}
impl Request for InstallColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        81
    }
}
#[derive(Default, Debug, Clone)]
pub struct UninstallColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for UninstallColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { cmap })
    }
}
impl Request for UninstallColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        82
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListInstalledColormapsRequest {
    pub window: Window,
}
impl AsByteSequence for ListInstalledColormapsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListInstalledColormapsReply {
    pub cmaps: Vec<Colormap>,
}
impl AsByteSequence for ListInstalledColormapsReply {
    #[inline]
    fn size() -> usize {
        <*mut Colormap>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.cmaps.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.cmaps.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len2890643526: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let cmaps: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Colormap>::size();
        let cmaps: Vec<Colormap> = unsafe { clone_from_ptr(cmaps, len2890643526) };
        Some(Self { cmaps })
    }
}
impl Request for ListInstalledColormapsRequest {
    type Reply = ListInstalledColormapsReply;
    #[inline]
    fn opcode() -> Byte {
        83
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorRequest {
    pub cmap: Colormap,
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
}
impl AsByteSequence for AllocColorRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Card16>::size() + <Card16>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            cmap,
            red,
            green,
            blue,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorReply {
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
    pub pixel: Card32,
}
impl AsByteSequence for AllocColorReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + 2 + <Card16>::size() + <Card16>::size() + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
        self.pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        let pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self {
            red,
            green,
            blue,
            pixel,
        })
    }
}
impl Request for AllocColorRequest {
    type Reply = AllocColorReply;
    #[inline]
    fn opcode() -> Byte {
        84
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocNamedColorRequest {
    pub cmap: Colormap,
    pub name: String,
}
impl AsByteSequence for AllocNamedColorRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let len3300945858: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len3300945858) };
        Some(Self { cmap, name })
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocNamedColorReply {
    pub pixel: Card32,
    pub exact_red: Card16,
    pub exact_green: Card16,
    pub exact_blue: Card16,
    pub visual_red: Card16,
    pub visual_green: Card16,
    pub visual_blue: Card16,
}
impl AsByteSequence for AllocNamedColorReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.exact_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.exact_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.exact_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let exact_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let exact_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let exact_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            pixel,
            exact_red,
            exact_green,
            exact_blue,
            visual_red,
            visual_green,
            visual_blue,
        })
    }
}
impl Request for AllocNamedColorRequest {
    type Reply = AllocNamedColorReply;
    #[inline]
    fn opcode() -> Byte {
        85
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorCellsRequest {
    pub contiguous: ::std::os::raw::c_char,
    pub cmap: Colormap,
    pub colors: Card16,
    pub planes: Card16,
}
impl AsByteSequence for AllocColorCellsRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Colormap>::size() + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.contiguous.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.colors.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.planes.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let contiguous: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let colors: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let planes: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            contiguous,
            cmap,
            colors,
            planes,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorCellsReply {
    pub pixels: Vec<Card32>,
    pub masks: Vec<Card32>,
}
impl AsByteSequence for AllocColorCellsReply {
    #[inline]
    fn size() -> usize {
        <*mut Card32>::size() + <*mut Card32>::size() + 20 + 2 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.pixels.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        (self.masks.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 20;
        self.pixels.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card32>::size();
        self.masks.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len2146954442: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let len3524341501: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 20;
        let pixels: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card32>::size();
        let pixels: Vec<Card32> = unsafe { clone_from_ptr(pixels, len2146954442) };
        let masks: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card32>::size();
        let masks: Vec<Card32> = unsafe { clone_from_ptr(masks, len3524341501) };
        Some(Self { pixels, masks })
    }
}
impl Request for AllocColorCellsRequest {
    type Reply = AllocColorCellsReply;
    #[inline]
    fn opcode() -> Byte {
        86
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorPlanesRequest {
    pub contiguous: ::std::os::raw::c_char,
    pub cmap: Colormap,
    pub colors: Card16,
    pub reds: Card16,
    pub greens: Card16,
    pub blues: Card16,
}
impl AsByteSequence for AllocColorPlanesRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Colormap>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.contiguous.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.colors.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.reds.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.greens.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.blues.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let contiguous: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let colors: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let reds: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let greens: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let blues: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            contiguous,
            cmap,
            colors,
            reds,
            greens,
            blues,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorPlanesReply {
    pub red_mask: Card32,
    pub green_mask: Card32,
    pub blue_mask: Card32,
    pub pixels: Vec<Card32>,
}
impl AsByteSequence for AllocColorPlanesReply {
    #[inline]
    fn size() -> usize {
        <*mut Card32>::size()
            + 8
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + 2
            + 2
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.pixels.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.red_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.green_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.blue_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        index += 8;
        self.pixels.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len2471850239: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let red_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let green_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let blue_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        index += 8;
        let pixels: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card32>::size();
        let pixels: Vec<Card32> = unsafe { clone_from_ptr(pixels, len2471850239) };
        Some(Self {
            red_mask,
            green_mask,
            blue_mask,
            pixels,
        })
    }
}
impl Request for AllocColorPlanesRequest {
    type Reply = AllocColorPlanesReply;
    #[inline]
    fn opcode() -> Byte {
        87
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeColorsRequest {
    pub cmap: Colormap,
    pub plane_mask: Card32,
}
impl AsByteSequence for FreeColorsRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.plane_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let plane_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self { cmap, plane_mask })
    }
}
impl Request for FreeColorsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        88
    }
}
#[derive(Default, Debug, Clone)]
pub struct Coloritem {
    pub pixel: Card32,
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
    pub flags: Byte,
}
impl AsByteSequence for Coloritem {
    #[inline]
    fn size() -> usize {
        1 + <Byte>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.flags.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let flags: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 1;
        Some(Self {
            pixel,
            red,
            green,
            blue,
            flags,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct StoreColorsRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for StoreColorsRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { cmap })
    }
}
impl Request for StoreColorsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        89
    }
}
#[derive(Default, Debug, Clone)]
pub struct StoreNamedColorRequest {
    pub flags: Card8,
    pub cmap: Colormap,
    pub pixel: Card32,
    pub name: String,
}
impl AsByteSequence for StoreNamedColorRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + <Card32>::size() + <Colormap>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.flags.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.pixel.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let flags: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let pixel: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let len3778158565: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len3778158565) };
        Some(Self {
            flags,
            cmap,
            pixel,
            name,
        })
    }
}
impl Request for StoreNamedColorRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        90
    }
}
#[derive(Default, Debug, Clone)]
pub struct Rgb {
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
}
impl AsByteSequence for Rgb {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Card16>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self { red, green, blue })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryColorsRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for QueryColorsRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        Some(Self { cmap })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryColorsReply {
    pub colors: Vec<Rgb>,
}
impl AsByteSequence for QueryColorsReply {
    #[inline]
    fn size() -> usize {
        <*mut Rgb>::size() + 22 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.colors.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.colors.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Rgb>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len1259958700: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let colors: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Rgb>::size();
        let colors: Vec<Rgb> = unsafe { clone_from_ptr(colors, len1259958700) };
        Some(Self { colors })
    }
}
impl Request for QueryColorsRequest {
    type Reply = QueryColorsReply;
    #[inline]
    fn opcode() -> Byte {
        91
    }
}
#[derive(Default, Debug, Clone)]
pub struct LookupColorRequest {
    pub cmap: Colormap,
    pub name: String,
}
impl AsByteSequence for LookupColorRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cmap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cmap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let len3857194031: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len3857194031) };
        Some(Self { cmap, name })
    }
}
#[derive(Default, Debug, Clone)]
pub struct LookupColorReply {
    pub exact_red: Card16,
    pub exact_green: Card16,
    pub exact_blue: Card16,
    pub visual_red: Card16,
    pub visual_green: Card16,
    pub visual_blue: Card16,
}
impl AsByteSequence for LookupColorReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.exact_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.exact_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.exact_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.visual_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let exact_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let exact_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let exact_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let visual_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            exact_red,
            exact_green,
            exact_blue,
            visual_red,
            visual_green,
            visual_blue,
        })
    }
}
impl Request for LookupColorRequest {
    type Reply = LookupColorReply;
    #[inline]
    fn opcode() -> Byte {
        92
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateCursorRequest {
    pub cid: Cursor,
    pub source: Pixmap,
    pub mask: Pixmap,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
    pub x: Card16,
    pub y: Card16,
}
impl AsByteSequence for CreateCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Pixmap>::size()
            + <Pixmap>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cid.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.source.as_bytes(&mut bytes[index..]);
        index += <Pixmap>::size();
        self.mask.as_bytes(&mut bytes[index..]);
        index += <Pixmap>::size();
        self.fore_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cid: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let source: Pixmap = <Pixmap>::from_bytes(&bytes[index..])?;
        index += <Pixmap>::size();
        let mask: Pixmap = <Pixmap>::from_bytes(&bytes[index..])?;
        index += <Pixmap>::size();
        let fore_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let x: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let y: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            cid,
            source,
            mask,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
            x,
            y,
        })
    }
}
impl Request for CreateCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        93
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateGlyphCursorRequest {
    pub cid: Cursor,
    pub source_font: Font,
    pub mask_font: Font,
    pub source_char: Card16,
    pub mask_char: Card16,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
}
impl AsByteSequence for CreateGlyphCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Font>::size()
            + <Font>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cid.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.source_font.as_bytes(&mut bytes[index..]);
        index += <Font>::size();
        self.mask_font.as_bytes(&mut bytes[index..]);
        index += <Font>::size();
        self.source_char.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.mask_char.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cid: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let source_font: Font = <Font>::from_bytes(&bytes[index..])?;
        index += <Font>::size();
        let mask_font: Font = <Font>::from_bytes(&bytes[index..])?;
        index += <Font>::size();
        let source_char: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let mask_char: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            cid,
            source_font,
            mask_font,
            source_char,
            mask_char,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        })
    }
}
impl Request for CreateGlyphCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        94
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeCursorRequest {
    pub cursor: Cursor,
}
impl AsByteSequence for FreeCursorRequest {
    #[inline]
    fn size() -> usize {
        <Cursor>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cursor.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cursor: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        Some(Self { cursor })
    }
}
impl Request for FreeCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        95
    }
}
#[derive(Default, Debug, Clone)]
pub struct RecolorCursorRequest {
    pub cursor: Cursor,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
}
impl AsByteSequence for RecolorCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.cursor.as_bytes(&mut bytes[index..]);
        index += <Cursor>::size();
        self.fore_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.fore_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_red.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_green.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.back_blue.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let cursor: Cursor = <Cursor>::from_bytes(&bytes[index..])?;
        index += <Cursor>::size();
        let fore_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let fore_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_red: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_green: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let back_blue: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            cursor,
            fore_red,
            fore_green,
            fore_blue,
            back_red,
            back_green,
            back_blue,
        })
    }
}
impl Request for RecolorCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        96
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryBestSizeRequest {
    pub class: Card8,
    pub drawable: Drawable,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for QueryBestSizeRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Drawable>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.class.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let class: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            class,
            drawable,
            width,
            height,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryBestSizeReply {
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for QueryBestSizeReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self { width, height })
    }
}
impl Request for QueryBestSizeRequest {
    type Reply = QueryBestSizeReply;
    #[inline]
    fn opcode() -> Byte {
        97
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryExtensionRequest {
    pub name: String,
}
impl AsByteSequence for QueryExtensionRequest {
    #[inline]
    fn size() -> usize {
        <*mut bool>::size() + 2 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 2;
        self.name.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut bool>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let len1773224762: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 2;
        let name: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut bool>::size();
        let name: String = unsafe { string_from_ptr(name, len1773224762) };
        Some(Self { name })
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryExtensionReply {
    pub present: ::std::os::raw::c_char,
    pub major_opcode: Card8,
    pub first_event: Card8,
    pub first_error: Card8,
}
impl AsByteSequence for QueryExtensionReply {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Card8>::size() + <Card8>::size() + <::std::os::raw::c_char>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.present.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.major_opcode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.first_event.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.first_error.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let present: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let major_opcode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let first_event: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let first_error: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self {
            present,
            major_opcode,
            first_event,
            first_error,
        })
    }
}
impl Request for QueryExtensionRequest {
    type Reply = QueryExtensionReply;
    #[inline]
    fn opcode() -> Byte {
        98
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListExtensionsRequest;
impl AsByteSequence for ListExtensionsRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListExtensionsReply {
    pub names: Vec<String>,
}
impl AsByteSequence for ListExtensionsReply {
    #[inline]
    fn size() -> usize {
        <*mut String>::size() + 24 + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.names.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 24;
        self.names.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut String>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len2711585018: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 24;
        let names: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut String>::size();
        let names: Vec<String> = unsafe { clone_from_ptr(names, len2711585018) };
        Some(Self { names })
    }
}
impl Request for ListExtensionsRequest {
    type Reply = ListExtensionsReply;
    #[inline]
    fn opcode() -> Byte {
        99
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeKeyboardMappingRequest {
    pub keycode_count: Card8,
    pub first_keycode: Keycode,
    pub keysyms_per_keycode: Card8,
    pub keysyms: Vec<Keysym>,
}
impl AsByteSequence for ChangeKeyboardMappingRequest {
    #[inline]
    fn size() -> usize {
        <*mut Keysym>::size() + 2 + <Card8>::size() + <Keycode>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.keycode_count.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.first_keycode.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.keysyms_per_keycode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 2;
        self.keysyms.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Keysym>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let keycode_count: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let first_keycode: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let keysyms_per_keycode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 2;
        let keysyms: Vec<Keysym> = <Vec<Keysym>>::from_bytes(&bytes[index..])?;
        index += <*mut Keysym>::size();
        Some(Self {
            keycode_count,
            first_keycode,
            keysyms_per_keycode,
            keysyms,
        })
    }
}
impl Request for ChangeKeyboardMappingRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        100
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardMappingRequest {
    pub first_keycode: Keycode,
    pub count: Card8,
}
impl AsByteSequence for GetKeyboardMappingRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Keycode>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.first_keycode.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.count.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let first_keycode: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let count: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self {
            first_keycode,
            count,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardMappingReply {
    pub keysyms_per_keycode: Byte,
    pub keysyms: Vec<Keysym>,
}
impl AsByteSequence for GetKeyboardMappingReply {
    #[inline]
    fn size() -> usize {
        <*mut Keysym>::size() + 24 + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.keysyms_per_keycode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 24;
        self.keysyms.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Keysym>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let keysyms_per_keycode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 24;
        Some(Self {
            keysyms_per_keycode,
            keysyms,
        })
    }
}
impl Request for GetKeyboardMappingRequest {
    type Reply = GetKeyboardMappingReply;
    #[inline]
    fn opcode() -> Byte {
        101
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeKeyboardControlRequest {}
impl AsByteSequence for ChangeKeyboardControlRequest {
    #[inline]
    fn size() -> usize {
        1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        Some(Self {})
    }
}
impl Request for ChangeKeyboardControlRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        102
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardControlRequest;
impl AsByteSequence for GetKeyboardControlRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardControlReply {
    pub global_auto_repeat: Byte,
    pub led_mask: Card32,
    pub key_click_percent: Card8,
    pub bell_percent: Card8,
    pub bell_pitch: Card16,
    pub bell_duration: Card16,
    pub auto_repeats: [Card8; 32],
}
impl AsByteSequence for GetKeyboardControlReply {
    #[inline]
    fn size() -> usize {
        <[Card8; 32]>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.global_auto_repeat.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.led_mask.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
        self.key_click_percent.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bell_percent.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.bell_pitch.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.bell_duration.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
        self.auto_repeats.as_ptr().as_bytes(&mut bytes[index..]);
        index += <[Card8; 32]>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let global_auto_repeat: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let led_mask: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        let key_click_percent: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bell_percent: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let bell_pitch: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let bell_duration: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        let auto_repeats: [Card8; 32] = <[Card8; 32]>::from_bytes(&bytes[index..])?;
        index += <[Card8; 32]>::size();
        Some(Self {
            global_auto_repeat,
            led_mask,
            key_click_percent,
            bell_percent,
            bell_pitch,
            bell_duration,
            auto_repeats,
        })
    }
}
impl Request for GetKeyboardControlRequest {
    type Reply = GetKeyboardControlReply;
    #[inline]
    fn opcode() -> Byte {
        103
    }
}
#[derive(Default, Debug, Clone)]
pub struct BellRequest {
    pub percent: Int8,
}
impl AsByteSequence for BellRequest {
    #[inline]
    fn size() -> usize {
        <Int8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.percent.as_bytes(&mut bytes[index..]);
        index += <Int8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let percent: Int8 = <Int8>::from_bytes(&bytes[index..])?;
        index += <Int8>::size();
        Some(Self { percent })
    }
}
impl Request for BellRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        104
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangePointerControlRequest {
    pub acceleration_numerator: Int16,
    pub acceleration_denominator: Int16,
    pub threshold: Int16,
    pub do_acceleration: ::std::os::raw::c_char,
    pub do_threshold: ::std::os::raw::c_char,
}
impl AsByteSequence for ChangePointerControlRequest {
    #[inline]
    fn size() -> usize {
        <::std::os::raw::c_char>::size()
            + <::std::os::raw::c_char>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.acceleration_numerator.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.acceleration_denominator.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.threshold.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.do_acceleration.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.do_threshold.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let acceleration_numerator: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let acceleration_denominator: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let threshold: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let do_acceleration: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let do_threshold: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        Some(Self {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
            do_acceleration,
            do_threshold,
        })
    }
}
impl Request for ChangePointerControlRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        105
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerControlRequest;
impl AsByteSequence for GetPointerControlRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerControlReply {
    pub acceleration_numerator: Card16,
    pub acceleration_denominator: Card16,
    pub threshold: Card16,
}
impl AsByteSequence for GetPointerControlReply {
    #[inline]
    fn size() -> usize {
        18 + <Card16>::size() + <Card16>::size() + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.acceleration_numerator.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.acceleration_denominator.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.threshold.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 18;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let acceleration_numerator: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let acceleration_denominator: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let threshold: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 18;
        Some(Self {
            acceleration_numerator,
            acceleration_denominator,
            threshold,
        })
    }
}
impl Request for GetPointerControlRequest {
    type Reply = GetPointerControlReply;
    #[inline]
    fn opcode() -> Byte {
        106
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetScreenSaverRequest {
    pub timeout: Int16,
    pub interval: Int16,
    pub prefer_blanking: Card8,
    pub allow_exposures: Card8,
}
impl AsByteSequence for SetScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Card8>::size() + <Int16>::size() + <Int16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.timeout.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.interval.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.prefer_blanking.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.allow_exposures.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let timeout: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let interval: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let prefer_blanking: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let allow_exposures: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        })
    }
}
impl Request for SetScreenSaverRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        107
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetScreenSaverRequest;
impl AsByteSequence for GetScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetScreenSaverReply {
    pub timeout: Card16,
    pub interval: Card16,
    pub prefer_blanking: Byte,
    pub allow_exposures: Byte,
}
impl AsByteSequence for GetScreenSaverReply {
    #[inline]
    fn size() -> usize {
        18 + <Byte>::size() + <Byte>::size() + <Card16>::size() + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.timeout.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.interval.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.prefer_blanking.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.allow_exposures.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 18;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let timeout: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let interval: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let prefer_blanking: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let allow_exposures: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 18;
        Some(Self {
            timeout,
            interval,
            prefer_blanking,
            allow_exposures,
        })
    }
}
impl Request for GetScreenSaverRequest {
    type Reply = GetScreenSaverReply;
    #[inline]
    fn opcode() -> Byte {
        108
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeHostsRequest {
    pub mode: Card8,
    pub family: Card8,
    pub address: Vec<Byte>,
}
impl AsByteSequence for ChangeHostsRequest {
    #[inline]
    fn size() -> usize {
        <*mut Byte>::size() + 2 + 1 + <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.family.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        (self.address.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.address.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let family: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let len2394556123: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let address: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Byte>::size();
        let address: Vec<Byte> = unsafe { clone_from_ptr(address, len2394556123) };
        Some(Self {
            mode,
            family,
            address,
        })
    }
}
impl Request for ChangeHostsRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        109
    }
}
#[derive(Default, Debug, Clone)]
pub struct Host {
    pub family: Card8,
    pub address: Vec<Byte>,
}
impl AsByteSequence for Host {
    #[inline]
    fn size() -> usize {
        <*mut Byte>::size() + 2 + 1 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.family.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
        (self.address.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.address.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let family: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        let len3918002011: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let address: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Byte>::size();
        let address: Vec<Byte> = unsafe { clone_from_ptr(address, len3918002011) };
        Some(Self { family, address })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListHostsRequest;
impl AsByteSequence for ListHostsRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListHostsReply {
    pub mode: Byte,
    pub hosts: Vec<Host>,
}
impl AsByteSequence for ListHostsReply {
    #[inline]
    fn size() -> usize {
        <*mut Host>::size() + 22 + 2 + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        (self.hosts.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 22;
        self.hosts.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Host>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let len1313760079: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 22;
        let hosts: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Host>::size();
        let hosts: Vec<Host> = unsafe { clone_from_ptr(hosts, len1313760079) };
        Some(Self { mode, hosts })
    }
}
impl Request for ListHostsRequest {
    type Reply = ListHostsReply;
    #[inline]
    fn opcode() -> Byte {
        110
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetAccessControlRequest {
    pub mode: Card8,
}
impl AsByteSequence for SetAccessControlRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self { mode })
    }
}
impl Request for SetAccessControlRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        111
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetCloseDownModeRequest {
    pub mode: Card8,
}
impl AsByteSequence for SetCloseDownModeRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self { mode })
    }
}
impl Request for SetCloseDownModeRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        112
    }
}
#[derive(Default, Debug, Clone)]
pub struct KillClientRequest {
    pub resource: Card32,
}
impl AsByteSequence for KillClientRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.resource.as_bytes(&mut bytes[index..]);
        index += <Card32>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let resource: Card32 = <Card32>::from_bytes(&bytes[index..])?;
        index += <Card32>::size();
        Some(Self { resource })
    }
}
impl Request for KillClientRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        113
    }
}
#[derive(Default, Debug, Clone)]
pub struct RotatePropertiesRequest {
    pub window: Window,
    pub delta: Int16,
    pub atoms: Vec<Atom>,
}
impl AsByteSequence for RotatePropertiesRequest {
    #[inline]
    fn size() -> usize {
        <*mut Atom>::size() + <Int16>::size() + 2 + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        (self.atoms.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.delta.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.atoms.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let len227030059: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let delta: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let atoms: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Atom>::size();
        let atoms: Vec<Atom> = unsafe { clone_from_ptr(atoms, len227030059) };
        Some(Self {
            window,
            delta,
            atoms,
        })
    }
}
impl Request for RotatePropertiesRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        114
    }
}
#[derive(Default, Debug, Clone)]
pub struct ForceScreenSaverRequest {
    pub mode: Card8,
}
impl AsByteSequence for ForceScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let mode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        Some(Self { mode })
    }
}
impl Request for ForceScreenSaverRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        115
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetPointerMappingRequest {
    pub map: Vec<Card8>,
}
impl AsByteSequence for SetPointerMappingRequest {
    #[inline]
    fn size() -> usize {
        <*mut Card8>::size() + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.map.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.map.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len4281002757: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let map: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card8>::size();
        let map: Vec<Card8> = unsafe { clone_from_ptr(map, len4281002757) };
        Some(Self { map })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetPointerMappingReply {
    pub status: Byte,
}
impl AsByteSequence for SetPointerMappingReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self { status })
    }
}
impl Request for SetPointerMappingRequest {
    type Reply = SetPointerMappingReply;
    #[inline]
    fn opcode() -> Byte {
        116
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerMappingRequest;
impl AsByteSequence for GetPointerMappingRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerMappingReply {
    pub map: Vec<Card8>,
}
impl AsByteSequence for GetPointerMappingReply {
    #[inline]
    fn size() -> usize {
        <*mut Card8>::size() + 24 + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.map.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 24;
        self.map.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Card8>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len2326360035: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 24;
        let map: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Card8>::size();
        let map: Vec<Card8> = unsafe { clone_from_ptr(map, len2326360035) };
        Some(Self { map })
    }
}
impl Request for GetPointerMappingRequest {
    type Reply = GetPointerMappingReply;
    #[inline]
    fn opcode() -> Byte {
        117
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetModifierMappingRequest {
    pub keycodes: Vec<Keycode>,
}
impl AsByteSequence for SetModifierMappingRequest {
    #[inline]
    fn size() -> usize {
        <*mut Keycode>::size() + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.keycodes.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        self.keycodes.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Keycode>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len19914725: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        let keycodes: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Keycode>::size();
        let keycodes: Vec<Keycode> = unsafe { clone_from_ptr(keycodes, len19914725) };
        Some(Self { keycodes })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetModifierMappingReply {
    pub status: Byte,
}
impl AsByteSequence for SetModifierMappingReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.status.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let status: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self { status })
    }
}
impl Request for SetModifierMappingRequest {
    type Reply = SetModifierMappingReply;
    #[inline]
    fn opcode() -> Byte {
        118
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetModifierMappingRequest;
impl AsByteSequence for GetModifierMappingRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetModifierMappingReply {
    pub keycodes: Vec<Keycode>,
}
impl AsByteSequence for GetModifierMappingReply {
    #[inline]
    fn size() -> usize {
        <*mut Keycode>::size() + 24 + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        (self.keycodes.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += 24;
        self.keycodes.as_ptr().as_bytes(&mut bytes[index..]);
        index += <*mut Keycode>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let len1896214219: i32 = <i32>::from_bytes(&bytes[index..])?;
        index += 2;
        index += 24;
        let keycodes: *const u8 = <*const u8>::from_bytes(&bytes[index..])?;
        index += <*mut Keycode>::size();
        let keycodes: Vec<Keycode> = unsafe { clone_from_ptr(keycodes, len1896214219) };
        Some(Self { keycodes })
    }
}
impl Request for GetModifierMappingRequest {
    type Reply = GetModifierMappingReply;
    #[inline]
    fn opcode() -> Byte {
        119
    }
}
#[derive(Default, Debug, Clone)]
pub struct NoOperationRequest;
impl AsByteSequence for NoOperationRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {}
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        Some(Self)
    }
}
impl Request for NoOperationRequest {
    type Reply = ();
    #[inline]
    fn opcode() -> Byte {
        127
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum VisualClass {
    StaticGray = 0,
    GrayScale = 1,
    StaticColor = 2,
    PseudoColor = 3,
    TrueColor = 4,
    DirectColor = 5,
}
impl AsByteSequence for VisualClass {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::StaticGray,
            1 => Self::GrayScale,
            2 => Self::StaticColor,
            3 => Self::PseudoColor,
            4 => Self::TrueColor,
            5 => Self::DirectColor,
            _ => return None,
        })
    }
}
impl Default for VisualClass {
    #[inline]
    fn default() -> Self {
        Self::StaticGray
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct EventMask {
    pub key_press: bool,
    pub key_release: bool,
    pub button_press: bool,
    pub button_release: bool,
    pub enter_window: bool,
    pub leave_window: bool,
    pub pointer_motion: bool,
    pub pointer_motion_hint: bool,
    pub button_one_motion: bool,
    pub button_two_motion: bool,
    pub button_three_motion: bool,
    pub button_four_motion: bool,
    pub button_five_motion: bool,
    pub button_motion: bool,
    pub keymap_state: bool,
    pub exposure: bool,
    pub visibility_change: bool,
    pub structure_notify: bool,
    pub resize_redirect: bool,
    pub substructure_notify: bool,
    pub substructure_redirect: bool,
    pub focus_change: bool,
    pub property_change: bool,
    pub color_map_change: bool,
    pub owner_grab_button: bool,
}
impl AsByteSequence for EventMask {
    #[inline]
    fn size(&self) -> usize {
        <Card32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: Card32 = 0;
        asb |= if self.key_press { 1 << 0 } else { 0 };
        asb |= if self.key_release { 1 << 1 } else { 0 };
        asb |= if self.button_press { 1 << 2 } else { 0 };
        asb |= if self.button_release { 1 << 3 } else { 0 };
        asb |= if self.enter_window { 1 << 4 } else { 0 };
        asb |= if self.leave_window { 1 << 5 } else { 0 };
        asb |= if self.pointer_motion { 1 << 6 } else { 0 };
        asb |= if self.pointer_motion_hint { 1 << 7 } else { 0 };
        asb |= if self.button_one_motion { 1 << 8 } else { 0 };
        asb |= if self.button_two_motion { 1 << 9 } else { 0 };
        asb |= if self.button_three_motion { 1 << 10 } else { 0 };
        asb |= if self.button_four_motion { 1 << 11 } else { 0 };
        asb |= if self.button_five_motion { 1 << 12 } else { 0 };
        asb |= if self.button_motion { 1 << 13 } else { 0 };
        asb |= if self.keymap_state { 1 << 14 } else { 0 };
        asb |= if self.exposure { 1 << 15 } else { 0 };
        asb |= if self.visibility_change { 1 << 16 } else { 0 };
        asb |= if self.structure_notify { 1 << 17 } else { 0 };
        asb |= if self.resize_redirect { 1 << 18 } else { 0 };
        asb |= if self.substructure_notify { 1 << 19 } else { 0 };
        asb |= if self.substructure_redirect {
            1 << 20
        } else {
            0
        };
        asb |= if self.focus_change { 1 << 21 } else { 0 };
        asb |= if self.property_change { 1 << 22 } else { 0 };
        asb |= if self.color_map_change { 1 << 23 } else { 0 };
        asb |= if self.owner_grab_button { 1 << 24 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: Card32 = <Card32>::from_bytes(bytes)?;
        let key_press: bool = ul & (1 << 0) != 0;
        let key_release: bool = ul & (1 << 1) != 0;
        let button_press: bool = ul & (1 << 2) != 0;
        let button_release: bool = ul & (1 << 3) != 0;
        let enter_window: bool = ul & (1 << 4) != 0;
        let leave_window: bool = ul & (1 << 5) != 0;
        let pointer_motion: bool = ul & (1 << 6) != 0;
        let pointer_motion_hint: bool = ul & (1 << 7) != 0;
        let button_one_motion: bool = ul & (1 << 8) != 0;
        let button_two_motion: bool = ul & (1 << 9) != 0;
        let button_three_motion: bool = ul & (1 << 10) != 0;
        let button_four_motion: bool = ul & (1 << 11) != 0;
        let button_five_motion: bool = ul & (1 << 12) != 0;
        let button_motion: bool = ul & (1 << 13) != 0;
        let keymap_state: bool = ul & (1 << 14) != 0;
        let exposure: bool = ul & (1 << 15) != 0;
        let visibility_change: bool = ul & (1 << 16) != 0;
        let structure_notify: bool = ul & (1 << 17) != 0;
        let resize_redirect: bool = ul & (1 << 18) != 0;
        let substructure_notify: bool = ul & (1 << 19) != 0;
        let substructure_redirect: bool = ul & (1 << 20) != 0;
        let focus_change: bool = ul & (1 << 21) != 0;
        let property_change: bool = ul & (1 << 22) != 0;
        let color_map_change: bool = ul & (1 << 23) != 0;
        let owner_grab_button: bool = ul & (1 << 24) != 0;
        Some(Self {
            key_press,
            key_release,
            button_press,
            button_release,
            enter_window,
            leave_window,
            pointer_motion,
            pointer_motion_hint,
            button_one_motion,
            button_two_motion,
            button_three_motion,
            button_four_motion,
            button_five_motion,
            button_motion,
            keymap_state,
            exposure,
            visibility_change,
            structure_notify,
            resize_redirect,
            substructure_notify,
            substructure_redirect,
            focus_change,
            property_change,
            color_map_change,
            owner_grab_button,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum BackingStore {
    NotUseful = 0,
    WhenMapped = 1,
    Always = 2,
}
impl AsByteSequence for BackingStore {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::NotUseful,
            1 => Self::WhenMapped,
            2 => Self::Always,
            _ => return None,
        })
    }
}
impl Default for BackingStore {
    #[inline]
    fn default() -> Self {
        Self::NotUseful
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ImageOrder {
    LsbFirst = 0,
    MsbFirst = 1,
}
impl AsByteSequence for ImageOrder {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::LsbFirst,
            1 => Self::MsbFirst,
            _ => return None,
        })
    }
}
impl Default for ImageOrder {
    #[inline]
    fn default() -> Self {
        Self::LsbFirst
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct KeyButMask {
    pub shift: bool,
    pub lock: bool,
    pub control: bool,
    pub mod_one: bool,
    pub mod_two: bool,
    pub mod_three: bool,
    pub mod_four: bool,
    pub mod_five: bool,
    pub button_one: bool,
    pub button_two: bool,
    pub button_three: bool,
    pub button_four: bool,
    pub button_five: bool,
}
impl AsByteSequence for KeyButMask {
    #[inline]
    fn size(&self) -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u16 = 0;
        asb |= if self.shift { 1 << 0 } else { 0 };
        asb |= if self.lock { 1 << 1 } else { 0 };
        asb |= if self.control { 1 << 2 } else { 0 };
        asb |= if self.mod_one { 1 << 3 } else { 0 };
        asb |= if self.mod_two { 1 << 4 } else { 0 };
        asb |= if self.mod_three { 1 << 5 } else { 0 };
        asb |= if self.mod_four { 1 << 6 } else { 0 };
        asb |= if self.mod_five { 1 << 7 } else { 0 };
        asb |= if self.button_one { 1 << 8 } else { 0 };
        asb |= if self.button_two { 1 << 9 } else { 0 };
        asb |= if self.button_three { 1 << 10 } else { 0 };
        asb |= if self.button_four { 1 << 11 } else { 0 };
        asb |= if self.button_five { 1 << 12 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u16 = <u16>::from_bytes(bytes)?;
        let shift: bool = ul & (1 << 0) != 0;
        let lock: bool = ul & (1 << 1) != 0;
        let control: bool = ul & (1 << 2) != 0;
        let mod_one: bool = ul & (1 << 3) != 0;
        let mod_two: bool = ul & (1 << 4) != 0;
        let mod_three: bool = ul & (1 << 5) != 0;
        let mod_four: bool = ul & (1 << 6) != 0;
        let mod_five: bool = ul & (1 << 7) != 0;
        let button_one: bool = ul & (1 << 8) != 0;
        let button_two: bool = ul & (1 << 9) != 0;
        let button_three: bool = ul & (1 << 10) != 0;
        let button_four: bool = ul & (1 << 11) != 0;
        let button_five: bool = ul & (1 << 12) != 0;
        Some(Self {
            shift,
            lock,
            control,
            mod_one,
            mod_two,
            mod_three,
            mod_four,
            mod_five,
            button_one,
            button_two,
            button_three,
            button_four,
            button_five,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Motion {
    Normal = 0,
    Hint = 1,
}
impl AsByteSequence for Motion {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Normal,
            1 => Self::Hint,
            _ => return None,
        })
    }
}
impl Default for Motion {
    #[inline]
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NotifyDetail {
    Ancestor = 0,
    Virtual = 1,
    Inferior = 2,
    Nonlinear = 3,
    NonlinearVirtual = 4,
    Pointer = 5,
    PointerRoot = 6,
    None = 7,
}
impl AsByteSequence for NotifyDetail {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Ancestor,
            1 => Self::Virtual,
            2 => Self::Inferior,
            3 => Self::Nonlinear,
            4 => Self::NonlinearVirtual,
            5 => Self::Pointer,
            6 => Self::PointerRoot,
            7 => Self::None,
            _ => return None,
        })
    }
}
impl Default for NotifyDetail {
    #[inline]
    fn default() -> Self {
        Self::Ancestor
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NotifyMode {
    Normal = 0,
    Grab = 1,
    Ungrab = 2,
    WhileGrabbed = 3,
}
impl AsByteSequence for NotifyMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Normal,
            1 => Self::Grab,
            2 => Self::Ungrab,
            3 => Self::WhileGrabbed,
            _ => return None,
        })
    }
}
impl Default for NotifyMode {
    #[inline]
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Visibility {
    Unobscured = 0,
    PartiallyObscured = 1,
    FullyObscured = 2,
}
impl AsByteSequence for Visibility {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Unobscured,
            1 => Self::PartiallyObscured,
            2 => Self::FullyObscured,
            _ => return None,
        })
    }
}
impl Default for Visibility {
    #[inline]
    fn default() -> Self {
        Self::Unobscured
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum StackMode {
    Above = 0,
    Below = 1,
    TopIf = 2,
    BottomIf = 3,
    Opposite = 4,
}
impl AsByteSequence for StackMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Above,
            1 => Self::Below,
            2 => Self::TopIf,
            3 => Self::BottomIf,
            4 => Self::Opposite,
            _ => return None,
        })
    }
}
impl Default for StackMode {
    #[inline]
    fn default() -> Self {
        Self::Above
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ConfigWindow {
    pub x: bool,
    pub y: bool,
    pub width: bool,
    pub height: bool,
    pub border_width: bool,
    pub sibling: bool,
    pub stack_mode: bool,
}
impl AsByteSequence for ConfigWindow {
    #[inline]
    fn size(&self) -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u16 = 0;
        asb |= if self.x { 1 << 0 } else { 0 };
        asb |= if self.y { 1 << 1 } else { 0 };
        asb |= if self.width { 1 << 2 } else { 0 };
        asb |= if self.height { 1 << 3 } else { 0 };
        asb |= if self.border_width { 1 << 4 } else { 0 };
        asb |= if self.sibling { 1 << 5 } else { 0 };
        asb |= if self.stack_mode { 1 << 6 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u16 = <u16>::from_bytes(bytes)?;
        let x: bool = ul & (1 << 0) != 0;
        let y: bool = ul & (1 << 1) != 0;
        let width: bool = ul & (1 << 2) != 0;
        let height: bool = ul & (1 << 3) != 0;
        let border_width: bool = ul & (1 << 4) != 0;
        let sibling: bool = ul & (1 << 5) != 0;
        let stack_mode: bool = ul & (1 << 6) != 0;
        Some(Self {
            x,
            y,
            width,
            height,
            border_width,
            sibling,
            stack_mode,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Place {
    OnTop = 0,
    OnBottom = 1,
}
impl AsByteSequence for Place {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::OnTop,
            1 => Self::OnBottom,
            _ => return None,
        })
    }
}
impl Default for Place {
    #[inline]
    fn default() -> Self {
        Self::OnTop
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Property {
    NewValue = 0,
    Delete = 1,
}
impl AsByteSequence for Property {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::NewValue,
            1 => Self::Delete,
            _ => return None,
        })
    }
}
impl Default for Property {
    #[inline]
    fn default() -> Self {
        Self::NewValue
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ColormapState {
    Uninstalled = 0,
    Installed = 1,
}
impl AsByteSequence for ColormapState {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Uninstalled,
            1 => Self::Installed,
            _ => return None,
        })
    }
}
impl Default for ColormapState {
    #[inline]
    fn default() -> Self {
        Self::Uninstalled
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Mapping {
    Modifier = 0,
    Keyboard = 1,
    Pointer = 2,
}
impl AsByteSequence for Mapping {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Modifier,
            1 => Self::Keyboard,
            2 => Self::Pointer,
            _ => return None,
        })
    }
}
impl Default for Mapping {
    #[inline]
    fn default() -> Self {
        Self::Modifier
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u16)]
pub enum WindowClass {
    CopyFromParent = 0,
    InputOutput = 1,
    InputOnly = 2,
}
impl AsByteSequence for WindowClass {
    #[inline]
    fn size(&self) -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u16).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u16 = <u16>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::CopyFromParent,
            1 => Self::InputOutput,
            2 => Self::InputOnly,
            _ => return None,
        })
    }
}
impl Default for WindowClass {
    #[inline]
    fn default() -> Self {
        Self::CopyFromParent
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Gravity {
    BitForget = 0,
    WinUnmap = 0,
    NorthWest = 1,
    North = 2,
    NorthEast = 3,
    West = 4,
    Center = 5,
    East = 6,
    SouthWest = 7,
    South = 8,
    SouthEast = 9,
    Static = 10,
}
impl AsByteSequence for Gravity {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::BitForget,
            0 => Self::WinUnmap,
            1 => Self::NorthWest,
            2 => Self::North,
            3 => Self::NorthEast,
            4 => Self::West,
            5 => Self::Center,
            6 => Self::East,
            7 => Self::SouthWest,
            8 => Self::South,
            9 => Self::SouthEast,
            10 => Self::Static,
            _ => return None,
        })
    }
}
impl Default for Gravity {
    #[inline]
    fn default() -> Self {
        Self::BitForget
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum MapState {
    Unmapped = 0,
    Unviewable = 1,
    Viewable = 2,
}
impl AsByteSequence for MapState {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Unmapped,
            1 => Self::Unviewable,
            2 => Self::Viewable,
            _ => return None,
        })
    }
}
impl Default for MapState {
    #[inline]
    fn default() -> Self {
        Self::Unmapped
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum SetMode {
    Insert = 0,
    Delete = 1,
}
impl AsByteSequence for SetMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Insert,
            1 => Self::Delete,
            _ => return None,
        })
    }
}
impl Default for SetMode {
    #[inline]
    fn default() -> Self {
        Self::Insert
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Circulate {
    RaiseLowest = 0,
    LowerHighest = 1,
}
impl AsByteSequence for Circulate {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::RaiseLowest,
            1 => Self::LowerHighest,
            _ => return None,
        })
    }
}
impl Default for Circulate {
    #[inline]
    fn default() -> Self {
        Self::RaiseLowest
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum PropMode {
    Replace = 0,
    Prepend = 1,
    Append = 2,
}
impl AsByteSequence for PropMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Replace,
            1 => Self::Prepend,
            2 => Self::Append,
            _ => return None,
        })
    }
}
impl Default for PropMode {
    #[inline]
    fn default() -> Self {
        Self::Replace
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum GrabMode {
    Sync = 0,
    Async = 1,
}
impl AsByteSequence for GrabMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Sync,
            1 => Self::Async,
            _ => return None,
        })
    }
}
impl Default for GrabMode {
    #[inline]
    fn default() -> Self {
        Self::Sync
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum GrabStatus {
    Success = 0,
    AlreadyGrabbed = 1,
    InvalidTime = 2,
    NotViewable = 3,
    Frozen = 4,
}
impl AsByteSequence for GrabStatus {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Success,
            1 => Self::AlreadyGrabbed,
            2 => Self::InvalidTime,
            3 => Self::NotViewable,
            4 => Self::Frozen,
            _ => return None,
        })
    }
}
impl Default for GrabStatus {
    #[inline]
    fn default() -> Self {
        Self::Success
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ButtonIndex {
    Any = 0,
    One = 1,
    Two = 2,
    Three = 3,
    Four = 4,
    Five = 5,
}
impl AsByteSequence for ButtonIndex {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Any,
            1 => Self::One,
            2 => Self::Two,
            3 => Self::Three,
            4 => Self::Four,
            5 => Self::Five,
            _ => return None,
        })
    }
}
impl Default for ButtonIndex {
    #[inline]
    fn default() -> Self {
        Self::Any
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ModMask {
    pub shift: bool,
    pub lock: bool,
    pub control: bool,
    pub one: bool,
    pub two: bool,
    pub three: bool,
    pub four: bool,
    pub five: bool,
    pub any: bool,
}
impl AsByteSequence for ModMask {
    #[inline]
    fn size(&self) -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u16 = 0;
        asb |= if self.shift { 1 << 0 } else { 0 };
        asb |= if self.lock { 1 << 1 } else { 0 };
        asb |= if self.control { 1 << 2 } else { 0 };
        asb |= if self.one { 1 << 3 } else { 0 };
        asb |= if self.two { 1 << 4 } else { 0 };
        asb |= if self.three { 1 << 5 } else { 0 };
        asb |= if self.four { 1 << 6 } else { 0 };
        asb |= if self.five { 1 << 7 } else { 0 };
        asb |= if self.any { 1 << 15 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u16 = <u16>::from_bytes(bytes)?;
        let shift: bool = ul & (1 << 0) != 0;
        let lock: bool = ul & (1 << 1) != 0;
        let control: bool = ul & (1 << 2) != 0;
        let one: bool = ul & (1 << 3) != 0;
        let two: bool = ul & (1 << 4) != 0;
        let three: bool = ul & (1 << 5) != 0;
        let four: bool = ul & (1 << 6) != 0;
        let five: bool = ul & (1 << 7) != 0;
        let any: bool = ul & (1 << 15) != 0;
        Some(Self {
            shift,
            lock,
            control,
            one,
            two,
            three,
            four,
            five,
            any,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Allow {
    AsyncPointer = 0,
    SyncPointer = 1,
    ReplayPointer = 2,
    AsyncKeyboard = 3,
    SyncKeyboard = 4,
    ReplayKeyboard = 5,
    AsyncBoth = 6,
    SyncBoth = 7,
}
impl AsByteSequence for Allow {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::AsyncPointer,
            1 => Self::SyncPointer,
            2 => Self::ReplayPointer,
            3 => Self::AsyncKeyboard,
            4 => Self::SyncKeyboard,
            5 => Self::ReplayKeyboard,
            6 => Self::AsyncBoth,
            7 => Self::SyncBoth,
            _ => return None,
        })
    }
}
impl Default for Allow {
    #[inline]
    fn default() -> Self {
        Self::AsyncPointer
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum InputFocus {
    None = 0,
    PointerRoot = 1,
    Parent = 2,
    FollowKeyboard = 3,
}
impl AsByteSequence for InputFocus {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::None,
            1 => Self::PointerRoot,
            2 => Self::Parent,
            3 => Self::FollowKeyboard,
            _ => return None,
        })
    }
}
impl Default for InputFocus {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum FontDraw {
    LeftToRight = 0,
    RightToLeft = 1,
}
impl AsByteSequence for FontDraw {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::LeftToRight,
            1 => Self::RightToLeft,
            _ => return None,
        })
    }
}
impl Default for FontDraw {
    #[inline]
    fn default() -> Self {
        Self::LeftToRight
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ClipOrdering {
    Unsorted = 0,
    YSorted = 1,
    YxSorted = 2,
    YxBanded = 3,
}
impl AsByteSequence for ClipOrdering {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Unsorted,
            1 => Self::YSorted,
            2 => Self::YxSorted,
            3 => Self::YxBanded,
            _ => return None,
        })
    }
}
impl Default for ClipOrdering {
    #[inline]
    fn default() -> Self {
        Self::Unsorted
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum CoordMode {
    Origin = 0,
    Previous = 1,
}
impl AsByteSequence for CoordMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Origin,
            1 => Self::Previous,
            _ => return None,
        })
    }
}
impl Default for CoordMode {
    #[inline]
    fn default() -> Self {
        Self::Origin
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum PolyShape {
    Complex = 0,
    Nonconvex = 1,
    Convex = 2,
}
impl AsByteSequence for PolyShape {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Complex,
            1 => Self::Nonconvex,
            2 => Self::Convex,
            _ => return None,
        })
    }
}
impl Default for PolyShape {
    #[inline]
    fn default() -> Self {
        Self::Complex
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ImageFormat {
    XyBitmap = 0,
    XyPixmap = 1,
    ZPixmap = 2,
}
impl AsByteSequence for ImageFormat {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::XyBitmap,
            1 => Self::XyPixmap,
            2 => Self::ZPixmap,
            _ => return None,
        })
    }
}
impl Default for ImageFormat {
    #[inline]
    fn default() -> Self {
        Self::XyBitmap
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ColormapAlloc {
    None = 0,
    All = 1,
}
impl AsByteSequence for ColormapAlloc {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::None,
            1 => Self::All,
            _ => return None,
        })
    }
}
impl Default for ColormapAlloc {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ColorFlag {
    pub red: bool,
    pub green: bool,
    pub blue: bool,
}
impl AsByteSequence for ColorFlag {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u8 = 0;
        asb |= if self.red { 1 << 0 } else { 0 };
        asb |= if self.green { 1 << 1 } else { 0 };
        asb |= if self.blue { 1 << 2 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        let red: bool = ul & (1 << 0) != 0;
        let green: bool = ul & (1 << 1) != 0;
        let blue: bool = ul & (1 << 2) != 0;
        Some(Self { red, green, blue })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum QueryShapeOf {
    LargestCursor = 0,
    FastestTile = 1,
    FastestStipple = 2,
}
impl AsByteSequence for QueryShapeOf {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::LargestCursor,
            1 => Self::FastestTile,
            2 => Self::FastestStipple,
            _ => return None,
        })
    }
}
impl Default for QueryShapeOf {
    #[inline]
    fn default() -> Self {
        Self::LargestCursor
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum AutoRepeatMode {
    Off = 0,
    On = 1,
    Default = 2,
}
impl AsByteSequence for AutoRepeatMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Off,
            1 => Self::On,
            2 => Self::Default,
            _ => return None,
        })
    }
}
impl Default for AutoRepeatMode {
    #[inline]
    fn default() -> Self {
        Self::Off
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Blanking {
    NotPreferred = 0,
    Preferred = 1,
    Default = 2,
}
impl AsByteSequence for Blanking {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::NotPreferred,
            1 => Self::Preferred,
            2 => Self::Default,
            _ => return None,
        })
    }
}
impl Default for Blanking {
    #[inline]
    fn default() -> Self {
        Self::NotPreferred
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Exposures {
    NotAllowed = 0,
    Allowed = 1,
    Default = 2,
}
impl AsByteSequence for Exposures {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::NotAllowed,
            1 => Self::Allowed,
            2 => Self::Default,
            _ => return None,
        })
    }
}
impl Default for Exposures {
    #[inline]
    fn default() -> Self {
        Self::NotAllowed
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum HostMode {
    Insert = 0,
    Delete = 1,
}
impl AsByteSequence for HostMode {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Insert,
            1 => Self::Delete,
            _ => return None,
        })
    }
}
impl Default for HostMode {
    #[inline]
    fn default() -> Self {
        Self::Insert
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Family {
    Internet = 0,
    DeCnet = 1,
    Chaos = 2,
    ServerInterpreted = 5,
    InternetSix = 6,
}
impl AsByteSequence for Family {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Internet,
            1 => Self::DeCnet,
            2 => Self::Chaos,
            5 => Self::ServerInterpreted,
            6 => Self::InternetSix,
            _ => return None,
        })
    }
}
impl Default for Family {
    #[inline]
    fn default() -> Self {
        Self::Internet
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum AccessControl {
    Disable = 0,
    Enable = 1,
}
impl AsByteSequence for AccessControl {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Disable,
            1 => Self::Enable,
            _ => return None,
        })
    }
}
impl Default for AccessControl {
    #[inline]
    fn default() -> Self {
        Self::Disable
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum CloseDown {
    DestroyAll = 0,
    RetainPermanent = 1,
    RetainTemporary = 2,
}
impl AsByteSequence for CloseDown {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::DestroyAll,
            1 => Self::RetainPermanent,
            2 => Self::RetainTemporary,
            _ => return None,
        })
    }
}
impl Default for CloseDown {
    #[inline]
    fn default() -> Self {
        Self::DestroyAll
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ScreenSaver {
    Reset = 0,
    Active = 1,
}
impl AsByteSequence for ScreenSaver {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Reset,
            1 => Self::Active,
            _ => return None,
        })
    }
}
impl Default for ScreenSaver {
    #[inline]
    fn default() -> Self {
        Self::Reset
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum MappingStatus {
    Success = 0,
    Busy = 1,
    Failure = 2,
}
impl AsByteSequence for MappingStatus {
    #[inline]
    fn size(&self) -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u8).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u8 = <u8>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Success,
            1 => Self::Busy,
            2 => Self::Failure,
            _ => return None,
        })
    }
}
impl Default for MappingStatus {
    #[inline]
    fn default() -> Self {
        Self::Success
    }
}
pub const WINDOW_NONE: Window = Window::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct ButtonMask {
    pub one: bool,
    pub two: bool,
    pub three: bool,
    pub four: bool,
    pub five: bool,
    pub any: bool,
}
impl AsByteSequence for ButtonMask {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u32 = 0;
        asb |= if self.one { 1 << 8 } else { 0 };
        asb |= if self.two { 1 << 9 } else { 0 };
        asb |= if self.three { 1 << 10 } else { 0 };
        asb |= if self.four { 1 << 11 } else { 0 };
        asb |= if self.five { 1 << 12 } else { 0 };
        asb |= if self.any { 1 << 15 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        let one: bool = ul & (1 << 8) != 0;
        let two: bool = ul & (1 << 9) != 0;
        let three: bool = ul & (1 << 10) != 0;
        let four: bool = ul & (1 << 11) != 0;
        let five: bool = ul & (1 << 12) != 0;
        let any: bool = ul & (1 << 15) != 0;
        Some(Self {
            one,
            two,
            three,
            four,
            five,
            any,
        })
    }
}
pub const ATOM_NONE: Atom = Atom::const_from_xid(0);
pub const ATOM_ANY: Atom = Atom::const_from_xid(0);
pub const ATOM_PRIMARY: Atom = Atom::const_from_xid(1);
pub const ATOM_SECONDARY: Atom = Atom::const_from_xid(2);
pub const ATOM_ARC: Atom = Atom::const_from_xid(3);
pub const ATOM_ATOM: Atom = Atom::const_from_xid(4);
pub const ATOM_BITMAP: Atom = Atom::const_from_xid(5);
pub const ATOM_CARDINAL: Atom = Atom::const_from_xid(6);
pub const ATOM_COLORMAP: Atom = Atom::const_from_xid(7);
pub const ATOM_CURSOR: Atom = Atom::const_from_xid(8);
pub const ATOM_CUT_BUFFER_ZERO: Atom = Atom::const_from_xid(9);
pub const ATOM_CUT_BUFFER_ONE: Atom = Atom::const_from_xid(10);
pub const ATOM_CUT_BUFFER_TWO: Atom = Atom::const_from_xid(11);
pub const ATOM_CUT_BUFFER_THREE: Atom = Atom::const_from_xid(12);
pub const ATOM_CUT_BUFFER_FOUR: Atom = Atom::const_from_xid(13);
pub const ATOM_CUT_BUFFER_FIVE: Atom = Atom::const_from_xid(14);
pub const ATOM_CUT_BUFFER_SIX: Atom = Atom::const_from_xid(15);
pub const ATOM_CUT_BUFFER_SEVEN: Atom = Atom::const_from_xid(16);
pub const ATOM_DRAWABLE: Atom = Atom::const_from_xid(17);
pub const ATOM_FONT: Atom = Atom::const_from_xid(18);
pub const ATOM_INTEGER: Atom = Atom::const_from_xid(19);
pub const ATOM_PIXMAP: Atom = Atom::const_from_xid(20);
pub const ATOM_POINT: Atom = Atom::const_from_xid(21);
pub const ATOM_RECTANGLE: Atom = Atom::const_from_xid(22);
pub const ATOM_RESOURCE_MANAGER: Atom = Atom::const_from_xid(23);
pub const ATOM_RGB_COLOR_MAP: Atom = Atom::const_from_xid(24);
pub const ATOM_RGB_BEST_MAP: Atom = Atom::const_from_xid(25);
pub const ATOM_RGB_BLUE_MAP: Atom = Atom::const_from_xid(26);
pub const ATOM_RGB_DEFAULT_MAP: Atom = Atom::const_from_xid(27);
pub const ATOM_RGB_GRAY_MAP: Atom = Atom::const_from_xid(28);
pub const ATOM_RGB_GREEN_MAP: Atom = Atom::const_from_xid(29);
pub const ATOM_RGB_RED_MAP: Atom = Atom::const_from_xid(30);
pub const ATOM_STRING: Atom = Atom::const_from_xid(31);
pub const ATOM_VISUALID: Atom = Atom::const_from_xid(32);
pub const ATOM_WINDOW: Atom = Atom::const_from_xid(33);
pub const ATOM_WM_COMMAND: Atom = Atom::const_from_xid(34);
pub const ATOM_WM_HINTS: Atom = Atom::const_from_xid(35);
pub const ATOM_WM_CLIENT_MACHINE: Atom = Atom::const_from_xid(36);
pub const ATOM_WM_ICON_NAME: Atom = Atom::const_from_xid(37);
pub const ATOM_WM_ICON_SIZE: Atom = Atom::const_from_xid(38);
pub const ATOM_WM_NAME: Atom = Atom::const_from_xid(39);
pub const ATOM_WM_NORMAL_HINTS: Atom = Atom::const_from_xid(40);
pub const ATOM_WM_SIZE_HINTS: Atom = Atom::const_from_xid(41);
pub const ATOM_WM_ZOOM_HINTS: Atom = Atom::const_from_xid(42);
pub const ATOM_MIN_SPACE: Atom = Atom::const_from_xid(43);
pub const ATOM_NORM_SPACE: Atom = Atom::const_from_xid(44);
pub const ATOM_MAX_SPACE: Atom = Atom::const_from_xid(45);
pub const ATOM_END_SPACE: Atom = Atom::const_from_xid(46);
pub const ATOM_SUPERSCRIPT_X: Atom = Atom::const_from_xid(47);
pub const ATOM_SUPERSCRIPT_Y: Atom = Atom::const_from_xid(48);
pub const ATOM_SUBSCRIPT_X: Atom = Atom::const_from_xid(49);
pub const ATOM_SUBSCRIPT_Y: Atom = Atom::const_from_xid(50);
pub const ATOM_UNDERLINE_POSITION: Atom = Atom::const_from_xid(51);
pub const ATOM_UNDERLINE_THICKNESS: Atom = Atom::const_from_xid(52);
pub const ATOM_STRIKEOUT_ASCENT: Atom = Atom::const_from_xid(53);
pub const ATOM_STRIKEOUT_DESCENT: Atom = Atom::const_from_xid(54);
pub const ATOM_ITALIC_ANGLE: Atom = Atom::const_from_xid(55);
pub const ATOM_X_HEIGHT: Atom = Atom::const_from_xid(56);
pub const ATOM_QUAD_WIDTH: Atom = Atom::const_from_xid(57);
pub const ATOM_WEIGHT: Atom = Atom::const_from_xid(58);
pub const ATOM_POINT_SIZE: Atom = Atom::const_from_xid(59);
pub const ATOM_RESOLUTION: Atom = Atom::const_from_xid(60);
pub const ATOM_COPYRIGHT: Atom = Atom::const_from_xid(61);
pub const ATOM_NOTICE: Atom = Atom::const_from_xid(62);
pub const ATOM_FONT_NAME: Atom = Atom::const_from_xid(63);
pub const ATOM_FAMILY_NAME: Atom = Atom::const_from_xid(64);
pub const ATOM_FULL_NAME: Atom = Atom::const_from_xid(65);
pub const ATOM_CAP_HEIGHT: Atom = Atom::const_from_xid(66);
pub const ATOM_WM_CLASS: Atom = Atom::const_from_xid(67);
pub const ATOM_WM_TRANSIENT_FOR: Atom = Atom::const_from_xid(68);
pub const COLORMAP_NONE: Colormap = Colormap::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct CW {
    pub back_pixmap: bool,
    pub back_pixel: bool,
    pub border_pixmap: bool,
    pub border_pixel: bool,
    pub bit_gravity: bool,
    pub win_gravity: bool,
    pub backing_store: bool,
    pub backing_planes: bool,
    pub backing_pixel: bool,
    pub override_redirect: bool,
    pub save_under: bool,
    pub event_mask: bool,
    pub dont_propagate: bool,
    pub colormap: bool,
    pub cursor: bool,
}
impl AsByteSequence for CW {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u32 = 0;
        asb |= if self.back_pixmap { 1 << 0 } else { 0 };
        asb |= if self.back_pixel { 1 << 1 } else { 0 };
        asb |= if self.border_pixmap { 1 << 2 } else { 0 };
        asb |= if self.border_pixel { 1 << 3 } else { 0 };
        asb |= if self.bit_gravity { 1 << 4 } else { 0 };
        asb |= if self.win_gravity { 1 << 5 } else { 0 };
        asb |= if self.backing_store { 1 << 6 } else { 0 };
        asb |= if self.backing_planes { 1 << 7 } else { 0 };
        asb |= if self.backing_pixel { 1 << 8 } else { 0 };
        asb |= if self.override_redirect { 1 << 9 } else { 0 };
        asb |= if self.save_under { 1 << 10 } else { 0 };
        asb |= if self.event_mask { 1 << 11 } else { 0 };
        asb |= if self.dont_propagate { 1 << 12 } else { 0 };
        asb |= if self.colormap { 1 << 13 } else { 0 };
        asb |= if self.cursor { 1 << 14 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        let back_pixmap: bool = ul & (1 << 0) != 0;
        let back_pixel: bool = ul & (1 << 1) != 0;
        let border_pixmap: bool = ul & (1 << 2) != 0;
        let border_pixel: bool = ul & (1 << 3) != 0;
        let bit_gravity: bool = ul & (1 << 4) != 0;
        let win_gravity: bool = ul & (1 << 5) != 0;
        let backing_store: bool = ul & (1 << 6) != 0;
        let backing_planes: bool = ul & (1 << 7) != 0;
        let backing_pixel: bool = ul & (1 << 8) != 0;
        let override_redirect: bool = ul & (1 << 9) != 0;
        let save_under: bool = ul & (1 << 10) != 0;
        let event_mask: bool = ul & (1 << 11) != 0;
        let dont_propagate: bool = ul & (1 << 12) != 0;
        let colormap: bool = ul & (1 << 13) != 0;
        let cursor: bool = ul & (1 << 14) != 0;
        Some(Self {
            back_pixmap,
            back_pixel,
            border_pixmap,
            border_pixel,
            bit_gravity,
            win_gravity,
            backing_store,
            backing_planes,
            backing_pixel,
            override_redirect,
            save_under,
            event_mask,
            dont_propagate,
            colormap,
            cursor,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum BackPixmap {
    None = 0,
    ParentRelative = 1,
}
impl AsByteSequence for BackPixmap {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::None,
            1 => Self::ParentRelative,
            _ => return None,
        })
    }
}
impl Default for BackPixmap {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum SendEventDest {
    PointerWindow = 0,
    ItemFocus = 1,
}
impl AsByteSequence for SendEventDest {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::PointerWindow,
            1 => Self::ItemFocus,
            _ => return None,
        })
    }
}
impl Default for SendEventDest {
    #[inline]
    fn default() -> Self {
        Self::PointerWindow
    }
}
pub const CURSOR_NONE: Cursor = Cursor::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct GC {
    pub function: bool,
    pub plane_mask: bool,
    pub foreground: bool,
    pub background: bool,
    pub line_width: bool,
    pub line_style: bool,
    pub cap_style: bool,
    pub join_style: bool,
    pub fill_style: bool,
    pub fill_rule: bool,
    pub tile: bool,
    pub stipple: bool,
    pub tile_stipple_origin_x: bool,
    pub tile_stipple_origin_y: bool,
    pub font: bool,
    pub subwindow_mode: bool,
    pub graphics_exposures: bool,
    pub clip_origin_x: bool,
    pub clip_origin_y: bool,
    pub clip_mask: bool,
    pub dash_offset: bool,
    pub dash_list: bool,
    pub arc_mode: bool,
}
impl AsByteSequence for GC {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u32 = 0;
        asb |= if self.function { 1 << 0 } else { 0 };
        asb |= if self.plane_mask { 1 << 1 } else { 0 };
        asb |= if self.foreground { 1 << 2 } else { 0 };
        asb |= if self.background { 1 << 3 } else { 0 };
        asb |= if self.line_width { 1 << 4 } else { 0 };
        asb |= if self.line_style { 1 << 5 } else { 0 };
        asb |= if self.cap_style { 1 << 6 } else { 0 };
        asb |= if self.join_style { 1 << 7 } else { 0 };
        asb |= if self.fill_style { 1 << 8 } else { 0 };
        asb |= if self.fill_rule { 1 << 9 } else { 0 };
        asb |= if self.tile { 1 << 10 } else { 0 };
        asb |= if self.stipple { 1 << 11 } else { 0 };
        asb |= if self.tile_stipple_origin_x {
            1 << 12
        } else {
            0
        };
        asb |= if self.tile_stipple_origin_y {
            1 << 13
        } else {
            0
        };
        asb |= if self.font { 1 << 14 } else { 0 };
        asb |= if self.subwindow_mode { 1 << 15 } else { 0 };
        asb |= if self.graphics_exposures { 1 << 16 } else { 0 };
        asb |= if self.clip_origin_x { 1 << 17 } else { 0 };
        asb |= if self.clip_origin_y { 1 << 18 } else { 0 };
        asb |= if self.clip_mask { 1 << 19 } else { 0 };
        asb |= if self.dash_offset { 1 << 20 } else { 0 };
        asb |= if self.dash_list { 1 << 21 } else { 0 };
        asb |= if self.arc_mode { 1 << 22 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        let function: bool = ul & (1 << 0) != 0;
        let plane_mask: bool = ul & (1 << 1) != 0;
        let foreground: bool = ul & (1 << 2) != 0;
        let background: bool = ul & (1 << 3) != 0;
        let line_width: bool = ul & (1 << 4) != 0;
        let line_style: bool = ul & (1 << 5) != 0;
        let cap_style: bool = ul & (1 << 6) != 0;
        let join_style: bool = ul & (1 << 7) != 0;
        let fill_style: bool = ul & (1 << 8) != 0;
        let fill_rule: bool = ul & (1 << 9) != 0;
        let tile: bool = ul & (1 << 10) != 0;
        let stipple: bool = ul & (1 << 11) != 0;
        let tile_stipple_origin_x: bool = ul & (1 << 12) != 0;
        let tile_stipple_origin_y: bool = ul & (1 << 13) != 0;
        let font: bool = ul & (1 << 14) != 0;
        let subwindow_mode: bool = ul & (1 << 15) != 0;
        let graphics_exposures: bool = ul & (1 << 16) != 0;
        let clip_origin_x: bool = ul & (1 << 17) != 0;
        let clip_origin_y: bool = ul & (1 << 18) != 0;
        let clip_mask: bool = ul & (1 << 19) != 0;
        let dash_offset: bool = ul & (1 << 20) != 0;
        let dash_list: bool = ul & (1 << 21) != 0;
        let arc_mode: bool = ul & (1 << 22) != 0;
        Some(Self {
            function,
            plane_mask,
            foreground,
            background,
            line_width,
            line_style,
            cap_style,
            join_style,
            fill_style,
            fill_rule,
            tile,
            stipple,
            tile_stipple_origin_x,
            tile_stipple_origin_y,
            font,
            subwindow_mode,
            graphics_exposures,
            clip_origin_x,
            clip_origin_y,
            clip_mask,
            dash_offset,
            dash_list,
            arc_mode,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum GX {
    Clear = 0,
    And = 1,
    AndReverse = 2,
    Copy = 3,
    AndInverted = 4,
    Noop = 5,
    Xor = 6,
    Or = 7,
    Nor = 8,
    Equiv = 9,
    Invert = 10,
    OrReverse = 11,
    CopyInverted = 12,
    OrInverted = 13,
    Nand = 14,
    Set = 15,
}
impl AsByteSequence for GX {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Clear,
            1 => Self::And,
            2 => Self::AndReverse,
            3 => Self::Copy,
            4 => Self::AndInverted,
            5 => Self::Noop,
            6 => Self::Xor,
            7 => Self::Or,
            8 => Self::Nor,
            9 => Self::Equiv,
            10 => Self::Invert,
            11 => Self::OrReverse,
            12 => Self::CopyInverted,
            13 => Self::OrInverted,
            14 => Self::Nand,
            15 => Self::Set,
            _ => return None,
        })
    }
}
impl Default for GX {
    #[inline]
    fn default() -> Self {
        Self::Clear
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum LineStyle {
    Solid = 0,
    OnOffDash = 1,
    DoubleDash = 2,
}
impl AsByteSequence for LineStyle {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Solid,
            1 => Self::OnOffDash,
            2 => Self::DoubleDash,
            _ => return None,
        })
    }
}
impl Default for LineStyle {
    #[inline]
    fn default() -> Self {
        Self::Solid
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum CapStyle {
    NotLast = 0,
    Butt = 1,
    Round = 2,
    Projecting = 3,
}
impl AsByteSequence for CapStyle {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::NotLast,
            1 => Self::Butt,
            2 => Self::Round,
            3 => Self::Projecting,
            _ => return None,
        })
    }
}
impl Default for CapStyle {
    #[inline]
    fn default() -> Self {
        Self::NotLast
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum JoinStyle {
    Miter = 0,
    Round = 1,
    Bevel = 2,
}
impl AsByteSequence for JoinStyle {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Miter,
            1 => Self::Round,
            2 => Self::Bevel,
            _ => return None,
        })
    }
}
impl Default for JoinStyle {
    #[inline]
    fn default() -> Self {
        Self::Miter
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum FillStyle {
    Solid = 0,
    Tiled = 1,
    Stippled = 2,
    OpaqueStippled = 3,
}
impl AsByteSequence for FillStyle {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Solid,
            1 => Self::Tiled,
            2 => Self::Stippled,
            3 => Self::OpaqueStippled,
            _ => return None,
        })
    }
}
impl Default for FillStyle {
    #[inline]
    fn default() -> Self {
        Self::Solid
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum FillRule {
    EvenOdd = 0,
    Winding = 1,
}
impl AsByteSequence for FillRule {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::EvenOdd,
            1 => Self::Winding,
            _ => return None,
        })
    }
}
impl Default for FillRule {
    #[inline]
    fn default() -> Self {
        Self::EvenOdd
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum SubwindowMode {
    ClipByChildren = 0,
    IncludeInferiors = 1,
}
impl AsByteSequence for SubwindowMode {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::ClipByChildren,
            1 => Self::IncludeInferiors,
            _ => return None,
        })
    }
}
impl Default for SubwindowMode {
    #[inline]
    fn default() -> Self {
        Self::ClipByChildren
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ArcMode {
    Chord = 0,
    PieSlice = 1,
}
impl AsByteSequence for ArcMode {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Chord,
            1 => Self::PieSlice,
            _ => return None,
        })
    }
}
impl Default for ArcMode {
    #[inline]
    fn default() -> Self {
        Self::Chord
    }
}
pub const PIXMAP_NONE: Pixmap = Pixmap::const_from_xid(0);
pub const FONT_NONE: Font = Font::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct KB {
    pub key_click_percent: bool,
    pub bell_percent: bool,
    pub bell_pitch: bool,
    pub bell_duration: bool,
    pub led: bool,
    pub led_mode: bool,
    pub key: bool,
    pub auto_repeat_mode: bool,
}
impl AsByteSequence for KB {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut asb: u32 = 0;
        asb |= if self.key_click_percent { 1 << 0 } else { 0 };
        asb |= if self.bell_percent { 1 << 1 } else { 0 };
        asb |= if self.bell_pitch { 1 << 2 } else { 0 };
        asb |= if self.bell_duration { 1 << 3 } else { 0 };
        asb |= if self.led { 1 << 4 } else { 0 };
        asb |= if self.led_mode { 1 << 5 } else { 0 };
        asb |= if self.key { 1 << 6 } else { 0 };
        asb |= if self.auto_repeat_mode { 1 << 7 } else { 0 };
        asb.as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        let key_click_percent: bool = ul & (1 << 0) != 0;
        let bell_percent: bool = ul & (1 << 1) != 0;
        let bell_pitch: bool = ul & (1 << 2) != 0;
        let bell_duration: bool = ul & (1 << 3) != 0;
        let led: bool = ul & (1 << 4) != 0;
        let led_mode: bool = ul & (1 << 5) != 0;
        let key: bool = ul & (1 << 6) != 0;
        let auto_repeat_mode: bool = ul & (1 << 7) != 0;
        Some(Self {
            key_click_percent,
            bell_percent,
            bell_pitch,
            bell_duration,
            led,
            led_mode,
            key,
            auto_repeat_mode,
        })
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum LedMode {
    Off = 0,
    On = 1,
}
impl AsByteSequence for LedMode {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Off,
            1 => Self::On,
            _ => return None,
        })
    }
}
impl Default for LedMode {
    #[inline]
    fn default() -> Self {
        Self::Off
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum MapIndex {
    Shift = 0,
    Lock = 1,
    Control = 2,
    One = 3,
    Two = 4,
    Three = 5,
    Four = 6,
    Five = 7,
}
impl AsByteSequence for MapIndex {
    #[inline]
    fn size(&self) -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        (self as u32).as_bytes(bytes);
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let ul: u32 = <u32>::from_bytes(bytes)?;
        Some(match ul {
            0 => Self::Shift,
            1 => Self::Lock,
            2 => Self::Control,
            3 => Self::One,
            4 => Self::Two,
            5 => Self::Three,
            6 => Self::Four,
            7 => Self::Five,
            _ => return None,
        })
    }
}
impl Default for MapIndex {
    #[inline]
    fn default() -> Self {
        Self::Shift
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for MapNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.override_redirect.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let override_redirect: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 3;
        Some(Self {
            event,
            window,
            override_redirect,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub from_configure: ::std::os::raw::c_char,
}
impl AsByteSequence for UnmapNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.from_configure.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let from_configure: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 3;
        Some(Self {
            event,
            window,
            from_configure,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ResizeRequestEvent {
    pub window: Window,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for ResizeRequestEvent {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            window,
            width,
            height,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GraphicsExposureEvent {
    pub drawable: Drawable,
    pub x: Card16,
    pub y: Card16,
    pub width: Card16,
    pub height: Card16,
    pub minor_opcode: Card16,
    pub count: Card16,
    pub major_opcode: Card8,
}
impl AsByteSequence for GraphicsExposureEvent {
    #[inline]
    fn size() -> usize {
        3 + <Card8>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.minor_opcode.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.count.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.major_opcode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let x: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let y: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let minor_opcode: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let count: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let major_opcode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 3;
        Some(Self {
            drawable,
            x,
            y,
            width,
            height,
            minor_opcode,
            count,
            major_opcode,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateRequest {
    pub event: Window,
    pub window: Window,
    pub place: Byte,
}
impl AsByteSequence for CirculateRequest {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + 4 + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        index += 4;
        self.place.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        index += 4;
        let place: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self {
            event,
            window,
            place,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeyRelease {
    pub detail: Keycode,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for KeyRelease {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            same_screen,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct MotionNotifyEvent {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for MotionNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            same_screen,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct FocusInEvent {
    pub detail: Byte,
    pub event: Window,
    pub mode: Byte,
}
impl AsByteSequence for FocusInEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self {
            detail,
            event,
            mode,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ReparentNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for ReparentNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.override_redirect.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let override_redirect: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 3;
        Some(Self {
            event,
            window,
            parent,
            x,
            y,
            override_redirect,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GravityNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for GravityNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        Some(Self {
            event,
            window,
            x,
            y,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub place: Byte,
}
impl AsByteSequence for CirculateNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + 4 + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        index += 4;
        self.place.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        index += 4;
        let place: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self {
            event,
            window,
            place,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateNotifyEvent {
    pub parent: Window,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for CreateNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.border_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.override_redirect.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let border_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let override_redirect: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            parent,
            window,
            x,
            y,
            width,
            height,
            border_width,
            override_redirect,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct PropertyNotifyEvent {
    pub window: Window,
    pub atom: Atom,
    pub time: Timestamp,
    pub state: Byte,
}
impl AsByteSequence for PropertyNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Timestamp>::size() + <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.atom.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let atom: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let state: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self {
            window,
            atom,
            time,
            state,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapRequestEvent {
    pub parent: Window,
    pub window: Window,
}
impl AsByteSequence for MapRequestEvent {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { parent, window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct VisibilityNotifyEvent {
    pub window: Window,
    pub state: Byte,
}
impl AsByteSequence for VisibilityNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let state: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self { window, state })
    }
}
#[derive(Default, Debug, Clone)]
pub struct NoExposureEvent {
    pub drawable: Drawable,
    pub minor_opcode: Card16,
    pub major_opcode: Card8,
}
impl AsByteSequence for NoExposureEvent {
    #[inline]
    fn size() -> usize {
        1 + <Card8>::size() + <Card16>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.drawable.as_bytes(&mut bytes[index..]);
        index += <Drawable>::size();
        self.minor_opcode.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.major_opcode.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let drawable: Drawable = <Drawable>::from_bytes(&bytes[index..])?;
        index += <Drawable>::size();
        let minor_opcode: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let major_opcode: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        Some(Self {
            drawable,
            minor_opcode,
            major_opcode,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureRequestEvent {
    pub stack_mode: Byte,
    pub parent: Window,
    pub window: Window,
    pub sibling: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub value_mask: Card16,
}
impl AsByteSequence for ConfigureRequestEvent {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.stack_mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.parent.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.sibling.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.border_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.value_mask.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let stack_mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let parent: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let sibling: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let border_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let value_mask: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        Some(Self {
            stack_mode,
            parent,
            window,
            sibling,
            x,
            y,
            width,
            height,
            border_width,
            value_mask,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeymapNotifyEvent {
    pub keys: [Card8; 31],
}
impl AsByteSequence for KeymapNotifyEvent {
    #[inline]
    fn size() -> usize {
        <[Card8; 31]>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.keys.as_ptr().as_bytes(&mut bytes[index..]);
        index += <[Card8; 31]>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let keys: [Card8; 31] = <[Card8; 31]>::from_bytes(&bytes[index..])?;
        index += <[Card8; 31]>::size();
        Some(Self { keys })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ButtonRelease {
    pub detail: Button,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for ButtonRelease {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Button>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Button>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Button = <Button>::from_bytes(&bytes[index..])?;
        index += <Button>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            same_screen,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ExposeEvent {
    pub window: Window,
    pub x: Card16,
    pub y: Card16,
    pub width: Card16,
    pub height: Card16,
    pub count: Card16,
}
impl AsByteSequence for ExposeEvent {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.count.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let y: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let count: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        index += 2;
        Some(Self {
            window,
            x,
            y,
            width,
            height,
            count,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionClearEvent {
    pub time: Timestamp,
    pub owner: Window,
    pub selection: Atom,
}
impl AsByteSequence for SelectionClearEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + <Window>::size() + <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.owner.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let owner: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self {
            time,
            owner,
            selection,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct GeGenericEvent {}
impl AsByteSequence for GeGenericEvent {
    #[inline]
    fn size() -> usize {
        22
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 22;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 22;
        Some(Self {})
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub above_sibling: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for ConfigureNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.above_sibling.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.height.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.border_width.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.override_redirect.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let above_sibling: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let height: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let border_width: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let override_redirect: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            event,
            window,
            above_sibling,
            x,
            y,
            width,
            height,
            border_width,
            override_redirect,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeyPressEvent {
    pub detail: Keycode,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for KeyPressEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            same_screen,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct LeaveNotify {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub mode: Byte,
    pub same_screen_focus: Byte,
}
impl AsByteSequence for LeaveNotify {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.same_screen_focus.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let same_screen_focus: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            mode,
            same_screen_focus,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct EnterNotifyEvent {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub mode: Byte,
    pub same_screen_focus: Byte,
}
impl AsByteSequence for EnterNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.same_screen_focus.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let same_screen_focus: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            mode,
            same_screen_focus,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct MappingNotifyEvent {
    pub request: Byte,
    pub first_keycode: Keycode,
    pub count: Card8,
}
impl AsByteSequence for MappingNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <Card8>::size() + <Keycode>::size() + <Byte>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.request.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.first_keycode.as_bytes(&mut bytes[index..]);
        index += <Keycode>::size();
        self.count.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let request: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let first_keycode: Keycode = <Keycode>::from_bytes(&bytes[index..])?;
        index += <Keycode>::size();
        let count: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        index += 1;
        Some(Self {
            request,
            first_keycode,
            count,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionRequestEvent {
    pub time: Timestamp,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
}
impl AsByteSequence for SelectionRequestEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.owner.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.requestor.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.target.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let owner: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let requestor: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let target: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self {
            time,
            owner,
            requestor,
            selection,
            target,
            property,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ButtonPressEvent {
    pub detail: Button,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for ButtonPressEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Button>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Button>::size();
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.root.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.child.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.root_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.root_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_x.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.event_y.as_bytes(&mut bytes[index..]);
        index += <Int16>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Card16>::size();
        self.same_screen.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        index += 1;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Button = <Button>::from_bytes(&bytes[index..])?;
        index += <Button>::size();
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let root: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let child: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let root_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let root_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_x: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let event_y: Int16 = <Int16>::from_bytes(&bytes[index..])?;
        index += <Int16>::size();
        let state: Card16 = <Card16>::from_bytes(&bytes[index..])?;
        index += <Card16>::size();
        let same_screen: ::std::os::raw::c_char =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        index += 1;
        Some(Self {
            detail,
            time,
            root,
            event,
            child,
            root_x,
            root_y,
            event_x,
            event_y,
            state,
            same_screen,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroyNotifyEvent {
    pub event: Window,
    pub window: Window,
}
impl AsByteSequence for DestroyNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        Some(Self { event, window })
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionNotifyEvent {
    pub time: Timestamp,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
}
impl AsByteSequence for SelectionNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.time.as_bytes(&mut bytes[index..]);
        index += <Timestamp>::size();
        self.requestor.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.selection.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.target.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.property.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let time: Timestamp = <Timestamp>::from_bytes(&bytes[index..])?;
        index += <Timestamp>::size();
        let requestor: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let selection: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let target: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let property: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        Some(Self {
            time,
            requestor,
            selection,
            target,
            property,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ClientMessageEvent {
    pub format: Card8,
    pub window: Window,
    pub type_: Atom,
    pub data: ClientMessageData,
}
impl AsByteSequence for ClientMessageEvent {
    #[inline]
    fn size() -> usize {
        <ClientMessageData>::size() + <Atom>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.format.as_bytes(&mut bytes[index..]);
        index += <Card8>::size();
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.type_.as_bytes(&mut bytes[index..]);
        index += <Atom>::size();
        self.data.as_bytes(&mut bytes[index..]);
        index += <ClientMessageData>::size();
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let format: Card8 = <Card8>::from_bytes(&bytes[index..])?;
        index += <Card8>::size();
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let type_: Atom = <Atom>::from_bytes(&bytes[index..])?;
        index += <Atom>::size();
        let data: ClientMessageData = <ClientMessageData>::from_bytes(&bytes[index..])?;
        index += <ClientMessageData>::size();
        Some(Self {
            format,
            window,
            type_,
            data,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct FocusOut {
    pub detail: Byte,
    pub event: Window,
    pub mode: Byte,
}
impl AsByteSequence for FocusOut {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        self.detail.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        self.event.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.mode.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 3;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        let detail: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        let event: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let mode: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 3;
        Some(Self {
            detail,
            event,
            mode,
        })
    }
}
#[derive(Default, Debug, Clone)]
pub struct ColormapNotifyEvent {
    pub window: Window,
    pub colormap: Colormap,
    pub new: ::std::os::raw::c_char,
    pub state: Byte,
}
impl AsByteSequence for ColormapNotifyEvent {
    #[inline]
    fn size() -> usize {
        2 + <Byte>::size()
            + <::std::os::raw::c_char>::size()
            + <Colormap>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) {
        let mut index = 0;
        index += 1;
        self.window.as_bytes(&mut bytes[index..]);
        index += <Window>::size();
        self.colormap.as_bytes(&mut bytes[index..]);
        index += <Colormap>::size();
        self.new.as_bytes(&mut bytes[index..]);
        index += <::std::os::raw::c_char>::size();
        self.state.as_bytes(&mut bytes[index..]);
        index += <Byte>::size();
        index += 2;
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<Self> {
        let mut index = 0;
        index += 1;
        let window: Window = <Window>::from_bytes(&bytes[index..])?;
        index += <Window>::size();
        let colormap: Colormap = <Colormap>::from_bytes(&bytes[index..])?;
        index += <Colormap>::size();
        let new: ::std::os::raw::c_char = <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += <::std::os::raw::c_char>::size();
        let state: Byte = <Byte>::from_bytes(&bytes[index..])?;
        index += <Byte>::size();
        index += 2;
        Some(Self {
            window,
            colormap,
            new,
            state,
        })
    }
}
