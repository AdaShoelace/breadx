// This file was automatically generated by the flutterbug_generator crate from "/home/jtnunley/Programming/Projects/exbound/xml/xproto.xml".
// This file is considered to be dual-licensed under the MIT and Apache 2.0 licenses.

use super::prelude::*;
#[derive(Default, Debug, Clone)]
pub struct Char2b {
    pub byteOne: Card8,
    pub byteTwo: Card8,
}
impl AsByteSequence for Char2b {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.byteOne.as_bytes(&mut bytes[index..]);
        index += self.byteTwo.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (byteOne, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (byteTwo, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { byteOne, byteTwo }, index))
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Window {
    inner: XID,
}
impl XidType for Window {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Window {
        Window { inner: xid }
    }
}
impl Default for Window {
    #[inline]
    fn default() -> Window {
        Window { inner: 0 }
    }
}
impl Window {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Window {
        Window { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Pixmap {
    inner: XID,
}
impl XidType for Pixmap {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Pixmap {
        Pixmap { inner: xid }
    }
}
impl Default for Pixmap {
    #[inline]
    fn default() -> Pixmap {
        Pixmap { inner: 0 }
    }
}
impl Pixmap {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Pixmap {
        Pixmap { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Cursor {
    inner: XID,
}
impl XidType for Cursor {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Cursor {
        Cursor { inner: xid }
    }
}
impl Default for Cursor {
    #[inline]
    fn default() -> Cursor {
        Cursor { inner: 0 }
    }
}
impl Cursor {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Cursor {
        Cursor { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Font {
    inner: XID,
}
impl XidType for Font {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Font {
        Font { inner: xid }
    }
}
impl Default for Font {
    #[inline]
    fn default() -> Font {
        Font { inner: 0 }
    }
}
impl Font {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Font {
        Font { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Gcontext {
    inner: XID,
}
impl XidType for Gcontext {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Gcontext {
        Gcontext { inner: xid }
    }
}
impl Default for Gcontext {
    #[inline]
    fn default() -> Gcontext {
        Gcontext { inner: 0 }
    }
}
impl Gcontext {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Gcontext {
        Gcontext { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Colormap {
    inner: XID,
}
impl XidType for Colormap {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Colormap {
        Colormap { inner: xid }
    }
}
impl Default for Colormap {
    #[inline]
    fn default() -> Colormap {
        Colormap { inner: 0 }
    }
}
impl Colormap {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Colormap {
        Colormap { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
#[repr(transparent)]
pub struct Atom {
    inner: XID,
}
impl XidType for Atom {
    #[inline]
    fn xid(&self) -> XID {
        self.inner
    }
    #[inline]
    fn from_xid(xid: XID) -> Atom {
        Atom { inner: xid }
    }
}
impl Default for Atom {
    #[inline]
    fn default() -> Atom {
        Atom { inner: 0 }
    }
}
impl Atom {
    #[inline]
    pub(crate) const fn const_from_xid(xid: XID) -> Atom {
        Atom { inner: xid }
    }
}
#[derive(Debug, Copy, Clone, Hash)]
pub enum Drawable {
    Window(Window),
    Pixmap(Pixmap),
}
impl XidType for Drawable {
    #[inline]
    fn xid(&self) -> XID {
        match self {
            Self::Window(i) => i.xid(),
            Self::Pixmap(i) => i.xid(),
        }
    }
    #[inline]
    fn from_xid(xid: XID) -> Self {
        Self::Window(Window::from_xid(xid))
    }
}
impl Default for Drawable {
    #[inline]
    fn default() -> Drawable {
        Drawable::Window(Default::default())
    }
}
#[derive(Debug, Copy, Clone, Hash)]
pub enum Fontable {
    Font(Font),
    Gcontext(Gcontext),
}
impl XidType for Fontable {
    #[inline]
    fn xid(&self) -> XID {
        match self {
            Self::Font(i) => i.xid(),
            Self::Gcontext(i) => i.xid(),
        }
    }
    #[inline]
    fn from_xid(xid: XID) -> Self {
        Self::Font(Font::from_xid(xid))
    }
}
impl Default for Fontable {
    #[inline]
    fn default() -> Fontable {
        Fontable::Font(Default::default())
    }
}
pub type Visualid = Card32;
pub type Timestamp = Card32;
pub type Keysym = Card32;
pub type Keycode = Card8;
pub type Button = Card8;
#[derive(Default, Debug, Clone)]
pub struct Point {
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for Point {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { x, y }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Rectangle {
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for Rectangle {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                x,
                y,
                width,
                height,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Arc {
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub angleOne: Int16,
    pub angleTwo: Int16,
}
impl AsByteSequence for Arc {
    #[inline]
    fn size() -> usize {
        <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.angleOne.as_bytes(&mut bytes[index..]);
        index += self.angleTwo.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (angleOne, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (angleTwo, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                x,
                y,
                width,
                height,
                angleOne,
                angleTwo,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Format {
    pub depth: Card8,
    pub bits_per_pixel: Card8,
    pub scanline_pad: Card8,
}
impl AsByteSequence for Format {
    #[inline]
    fn size() -> usize {
        5 + <Card8>::size() + <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += self.bits_per_pixel.as_bytes(&mut bytes[index..]);
        index += self.scanline_pad.as_bytes(&mut bytes[index..]);
        index += 5;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bits_per_pixel, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (scanline_pad, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 5;
        Some((
            Self {
                depth,
                bits_per_pixel,
                scanline_pad,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Visualtype {
    pub visual_id: Visualid,
    pub class: Card8,
    pub bits_per_rgb_value: Card8,
    pub colormap_entries: Card16,
    pub red_mask: Card32,
    pub green_mask: Card32,
    pub blue_mask: Card32,
}
impl AsByteSequence for Visualtype {
    #[inline]
    fn size() -> usize {
        4 + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card16>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Visualid>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.visual_id.as_bytes(&mut bytes[index..]);
        index += self.class.as_bytes(&mut bytes[index..]);
        index += self.bits_per_rgb_value.as_bytes(&mut bytes[index..]);
        index += self.colormap_entries.as_bytes(&mut bytes[index..]);
        index += self.red_mask.as_bytes(&mut bytes[index..]);
        index += self.green_mask.as_bytes(&mut bytes[index..]);
        index += self.blue_mask.as_bytes(&mut bytes[index..]);
        index += 4;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (visual_id, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        let (class, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bits_per_rgb_value, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (colormap_entries, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (red_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        Some((
            Self {
                visual_id,
                class,
                bits_per_rgb_value,
                colormap_entries,
                red_mask,
                green_mask,
                blue_mask,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Depth {
    pub depth: Card8,
    pub visuals: Vec<Visualtype>,
}
impl AsByteSequence for Depth {
    #[inline]
    fn size() -> usize {
        <Visualtype>::size() * 32 + 4 + 2 + 1 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.visuals.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 4;
        index += vector_as_bytes(&self.visuals, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len3035518040, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (visuals, sz): (Vec<Visualtype>, usize) = vector_from_bytes(bytes, len3035518040)?;
        index += sz;
        Some((Self { depth, visuals }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Screen {
    pub root: Window,
    pub default_colormap: Colormap,
    pub white_pixel: Card32,
    pub black_pixel: Card32,
    pub current_input_masks: Card32,
    pub width_in_pixels: Card16,
    pub height_in_pixels: Card16,
    pub width_in_millimeters: Card16,
    pub height_in_millimeters: Card16,
    pub min_installed_maps: Card16,
    pub max_installed_maps: Card16,
    pub root_visual: Visualid,
    pub backing_stores: Byte,
    pub save_unders: ::std::os::raw::c_char,
    pub root_depth: Card8,
    pub allowed_depths: Vec<Depth>,
}
impl AsByteSequence for Screen {
    #[inline]
    fn size() -> usize {
        <Depth>::size() * 32
            + 2
            + <Card8>::size()
            + <::std::os::raw::c_char>::size()
            + <Byte>::size()
            + <Visualid>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Colormap>::size()
            + <Window>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.default_colormap.as_bytes(&mut bytes[index..]);
        index += self.white_pixel.as_bytes(&mut bytes[index..]);
        index += self.black_pixel.as_bytes(&mut bytes[index..]);
        index += self.current_input_masks.as_bytes(&mut bytes[index..]);
        index += self.width_in_pixels.as_bytes(&mut bytes[index..]);
        index += self.height_in_pixels.as_bytes(&mut bytes[index..]);
        index += self.width_in_millimeters.as_bytes(&mut bytes[index..]);
        index += self.height_in_millimeters.as_bytes(&mut bytes[index..]);
        index += self.min_installed_maps.as_bytes(&mut bytes[index..]);
        index += self.max_installed_maps.as_bytes(&mut bytes[index..]);
        index += self.root_visual.as_bytes(&mut bytes[index..]);
        index += self.backing_stores.as_bytes(&mut bytes[index..]);
        index += self.save_unders.as_bytes(&mut bytes[index..]);
        index += self.root_depth.as_bytes(&mut bytes[index..]);
        index += (self.allowed_depths.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.allowed_depths, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (default_colormap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (white_pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (black_pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (current_input_masks, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width_in_pixels, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height_in_pixels, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width_in_millimeters, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height_in_millimeters, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (min_installed_maps, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_installed_maps, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_visual, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        let (backing_stores, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (save_unders, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3668846552, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (allowed_depths, sz): (Vec<Depth>, usize) = vector_from_bytes(bytes, len3668846552)?;
        index += sz;
        Some((
            Self {
                root,
                default_colormap,
                white_pixel,
                black_pixel,
                current_input_masks,
                width_in_pixels,
                height_in_pixels,
                width_in_millimeters,
                height_in_millimeters,
                min_installed_maps,
                max_installed_maps,
                root_visual,
                backing_stores,
                save_unders,
                root_depth,
                allowed_depths,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupRequest {
    pub byte_order: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub authorization_protocol_name: String,
    pub authorization_protocol_data: String,
}
impl AsByteSequence for SetupRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + <u8>::size() * 32
            + 2
            + 2
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.byte_order.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += (self.authorization_protocol_name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += (self.authorization_protocol_data.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.authorization_protocol_name, &mut bytes[index..]);
        index += string_as_bytes(&self.authorization_protocol_data, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (byte_order, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (protocol_major_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (protocol_minor_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3567981689, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3291291719, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (authorization_protocol_name, sz): (String, usize) =
            string_from_bytes(bytes, len3567981689)?;
        index += sz;
        let (authorization_protocol_data, sz): (String, usize) =
            string_from_bytes(bytes, len3291291719)?;
        index += sz;
        Some((
            Self {
                byte_order,
                protocol_major_version,
                protocol_minor_version,
                authorization_protocol_name,
                authorization_protocol_data,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupFailed {
    pub status: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub length: Card16,
    pub reason: String,
}
impl AsByteSequence for SetupFailed {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 2
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.status.as_bytes(&mut bytes[index..]);
        index += (self.reason.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += string_as_bytes(&self.reason, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (status, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len1757732072, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (protocol_major_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (protocol_minor_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (reason, sz): (String, usize) = string_from_bytes(bytes, len1757732072)?;
        index += sz;
        Some((
            Self {
                status,
                protocol_major_version,
                protocol_minor_version,
                length,
                reason,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetupAuthenticate {
    pub status: Card8,
    pub length: Card16,
    pub reason: String,
}
impl AsByteSequence for SetupAuthenticate {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + <Card16>::size() + 5 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.status.as_bytes(&mut bytes[index..]);
        index += 5;
        index += self.length.as_bytes(&mut bytes[index..]);
        index += string_as_bytes(&self.reason, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (status, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 5;
        let (length, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (reason, sz): (String, usize) =
            string_from_bytes(bytes, (length as u16 * 4) as Card16)?;
        index += sz;
        Some((
            Self {
                status,
                length,
                reason,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Setup {
    pub status: Card8,
    pub protocol_major_version: Card16,
    pub protocol_minor_version: Card16,
    pub length: Card16,
    pub release_number: Card32,
    pub resource_id_base: Card32,
    pub resource_id_mask: Card32,
    pub motion_buffer_size: Card32,
    pub maximum_request_length: Card16,
    pub image_byte_order: Card8,
    pub bitmap_format_bit_order: Card8,
    pub bitmap_format_scanline_unit: Card8,
    pub bitmap_format_scanline_pad: Card8,
    pub min_keycode: Keycode,
    pub max_keycode: Keycode,
    pub vendor: String,
    pub pixmap_formats: Vec<Format>,
    pub roots: Vec<Screen>,
}
impl AsByteSequence for Setup {
    #[inline]
    fn size() -> usize {
        <Screen>::size() * 32
            + <Format>::size() * 32
            + <u8>::size() * 32
            + 4
            + <Keycode>::size()
            + <Keycode>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card8>::size()
            + 2
            + 2
            + <Card16>::size()
            + 2
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.status.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.protocol_major_version.as_bytes(&mut bytes[index..]);
        index += self.protocol_minor_version.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.release_number.as_bytes(&mut bytes[index..]);
        index += self.resource_id_base.as_bytes(&mut bytes[index..]);
        index += self.resource_id_mask.as_bytes(&mut bytes[index..]);
        index += self.motion_buffer_size.as_bytes(&mut bytes[index..]);
        index += (self.vendor.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.maximum_request_length.as_bytes(&mut bytes[index..]);
        index += (self.roots.len() as Card16).as_bytes(&mut bytes[index..]);
        index += (self.pixmap_formats.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.image_byte_order.as_bytes(&mut bytes[index..]);
        index += self.bitmap_format_bit_order.as_bytes(&mut bytes[index..]);
        index += self
            .bitmap_format_scanline_unit
            .as_bytes(&mut bytes[index..]);
        index += self
            .bitmap_format_scanline_pad
            .as_bytes(&mut bytes[index..]);
        index += self.min_keycode.as_bytes(&mut bytes[index..]);
        index += self.max_keycode.as_bytes(&mut bytes[index..]);
        index += 4;
        index += string_as_bytes(&self.vendor, &mut bytes[index..]);
        index += vector_as_bytes(&self.pixmap_formats, &mut bytes[index..]);
        index += vector_as_bytes(&self.roots, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (status, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (protocol_major_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (protocol_minor_version, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (release_number, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (resource_id_base, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (resource_id_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (motion_buffer_size, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len4062678648, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (maximum_request_length, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len1151708899, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len2484786508, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (image_byte_order, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bitmap_format_bit_order, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bitmap_format_scanline_unit, sz): (Card8, usize) =
            <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bitmap_format_scanline_pad, sz): (Card8, usize) =
            <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (min_keycode, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_keycode, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (vendor, sz): (String, usize) = string_from_bytes(bytes, len4062678648)?;
        index += sz;
        let (pixmap_formats, sz): (Vec<Format>, usize) = vector_from_bytes(bytes, len2484786508)?;
        index += sz;
        let (roots, sz): (Vec<Screen>, usize) = vector_from_bytes(bytes, len1151708899)?;
        index += sz;
        Some((
            Self {
                status,
                protocol_major_version,
                protocol_minor_version,
                length,
                release_number,
                resource_id_base,
                resource_id_mask,
                motion_buffer_size,
                maximum_request_length,
                image_byte_order,
                bitmap_format_bit_order,
                bitmap_format_scanline_unit,
                bitmap_format_scanline_pad,
                min_keycode,
                max_keycode,
                vendor,
                pixmap_formats,
                roots,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateWindowRequest {
    pub depth: Card8,
    pub wid: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub class: Card16,
    pub visual: Visualid,
}
impl AsByteSequence for CreateWindowRequest {
    #[inline]
    fn size() -> usize {
        <Visualid>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += self.wid.as_bytes(&mut bytes[index..]);
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.border_width.as_bytes(&mut bytes[index..]);
        index += self.class.as_bytes(&mut bytes[index..]);
        index += self.visual.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (wid, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (border_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (class, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                depth,
                wid,
                parent,
                x,
                y,
                width,
                height,
                border_width,
                class,
                visual,
            },
            index,
        ))
    }
}
impl Request for CreateWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        1
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeWindowAttributesRequest {
    pub window: Window,
}
impl AsByteSequence for ChangeWindowAttributesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for ChangeWindowAttributesRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        2
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetWindowAttributesRequest {
    pub window: Window,
}
impl AsByteSequence for GetWindowAttributesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetWindowAttributesReply {
    pub sequence: Card16,
    pub length: Card32,
    pub backing_store: Card8,
    pub visual: Visualid,
    pub class: Card16,
    pub bit_gravity: Card8,
    pub win_gravity: Card8,
    pub backing_planes: Card32,
    pub backing_pixel: Card32,
    pub save_under: ::std::os::raw::c_char,
    pub map_is_installed: ::std::os::raw::c_char,
    pub map_state: Card8,
    pub override_redirect: ::std::os::raw::c_char,
    pub colormap: Colormap,
    pub all_event_masks: Card32,
    pub your_event_mask: Card32,
    pub do_not_propagate_mask: Card16,
}
impl AsByteSequence for GetWindowAttributesReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Colormap>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <::std::os::raw::c_char>::size()
            + <::std::os::raw::c_char>::size()
            + <Card32>::size()
            + <Card32>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card16>::size()
            + <Visualid>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.backing_store.as_bytes(&mut bytes[index..]);
        index += self.visual.as_bytes(&mut bytes[index..]);
        index += self.class.as_bytes(&mut bytes[index..]);
        index += self.bit_gravity.as_bytes(&mut bytes[index..]);
        index += self.win_gravity.as_bytes(&mut bytes[index..]);
        index += self.backing_planes.as_bytes(&mut bytes[index..]);
        index += self.backing_pixel.as_bytes(&mut bytes[index..]);
        index += self.save_under.as_bytes(&mut bytes[index..]);
        index += self.map_is_installed.as_bytes(&mut bytes[index..]);
        index += self.map_state.as_bytes(&mut bytes[index..]);
        index += self.override_redirect.as_bytes(&mut bytes[index..]);
        index += self.colormap.as_bytes(&mut bytes[index..]);
        index += self.all_event_masks.as_bytes(&mut bytes[index..]);
        index += self.your_event_mask.as_bytes(&mut bytes[index..]);
        index += self.do_not_propagate_mask.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (backing_store, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        let (class, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bit_gravity, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (win_gravity, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (backing_planes, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (backing_pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (save_under, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (map_is_installed, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (map_state, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (override_redirect, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (colormap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (all_event_masks, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (your_event_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (do_not_propagate_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                sequence,
                length,
                backing_store,
                visual,
                class,
                bit_gravity,
                win_gravity,
                backing_planes,
                backing_pixel,
                save_under,
                map_is_installed,
                map_state,
                override_redirect,
                colormap,
                all_event_masks,
                your_event_mask,
                do_not_propagate_mask,
            },
            index,
        ))
    }
}
impl Request for GetWindowAttributesRequest {
    type Reply = GetWindowAttributesReply;
    #[inline]
    fn opcode(&self) -> Byte {
        3
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroyWindowRequest {
    pub window: Window,
}
impl AsByteSequence for DestroyWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for DestroyWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        4
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroySubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for DestroySubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for DestroySubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        5
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeSaveSetRequest {
    pub mode: Byte,
    pub window: Window,
}
impl AsByteSequence for ChangeSaveSetRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mode, window }, index))
    }
}
impl Request for ChangeSaveSetRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        6
    }
}
#[derive(Default, Debug, Clone)]
pub struct ReparentWindowRequest {
    pub window: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for ReparentWindowRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                window,
                parent,
                x,
                y,
            },
            index,
        ))
    }
}
impl Request for ReparentWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        7
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapWindowRequest {
    pub window: Window,
}
impl AsByteSequence for MapWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for MapWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        8
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapSubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for MapSubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for MapSubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        9
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapWindowRequest {
    pub window: Window,
}
impl AsByteSequence for UnmapWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for UnmapWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        10
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapSubwindowsRequest {
    pub window: Window,
}
impl AsByteSequence for UnmapSubwindowsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
impl Request for UnmapSubwindowsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        11
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureWindowRequest {
    pub window: Window,
    pub value_mask: Card16,
}
impl AsByteSequence for ConfigureWindowRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.value_mask.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (value_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((Self { window, value_mask }, index))
    }
}
impl Request for ConfigureWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        12
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateWindowRequest {
    pub direction: Card8,
    pub window: Window,
}
impl AsByteSequence for CirculateWindowRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.direction.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (direction, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { direction, window }, index))
    }
}
impl Request for CirculateWindowRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        13
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetGeometryRequest {
    pub drawable: Drawable,
}
impl AsByteSequence for GetGeometryRequest {
    #[inline]
    fn size() -> usize {
        <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetGeometryReply {
    pub sequence: Card16,
    pub length: Card32,
    pub depth: Card8,
    pub root: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
}
impl AsByteSequence for GetGeometryReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.border_width.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (border_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                sequence,
                length,
                depth,
                root,
                x,
                y,
                width,
                height,
                border_width,
            },
            index,
        ))
    }
}
impl Request for GetGeometryRequest {
    type Reply = GetGeometryReply;
    #[inline]
    fn opcode(&self) -> Byte {
        14
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTreeRequest {
    pub window: Window,
}
impl AsByteSequence for QueryTreeRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTreeReply {
    pub sequence: Card16,
    pub length: Card32,
    pub root: Window,
    pub parent: Window,
    pub children: Vec<Window>,
}
impl AsByteSequence for QueryTreeReply {
    #[inline]
    fn size() -> usize {
        <Window>::size() * 32
            + 14
            + 2
            + <Window>::size()
            + <Window>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += (self.children.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 14;
        index += vector_as_bytes(&self.children, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3713747174, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 14;
        let (children, sz): (Vec<Window>, usize) = vector_from_bytes(bytes, len3713747174)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                root,
                parent,
                children,
            },
            index,
        ))
    }
}
impl Request for QueryTreeRequest {
    type Reply = QueryTreeReply;
    #[inline]
    fn opcode(&self) -> Byte {
        15
    }
}
#[derive(Default, Debug, Clone)]
pub struct InternAtomRequest {
    pub only_if_exists: ::std::os::raw::c_char,
    pub name: String,
}
impl AsByteSequence for InternAtomRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.only_if_exists.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (only_if_exists, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len1856391222, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len1856391222)?;
        index += sz;
        Some((
            Self {
                only_if_exists,
                name,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct InternAtomReply {
    pub sequence: Card16,
    pub length: Card32,
    pub atom: Atom,
}
impl AsByteSequence for InternAtomReply {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.atom.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (atom, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                atom,
            },
            index,
        ))
    }
}
impl Request for InternAtomRequest {
    type Reply = InternAtomReply;
    #[inline]
    fn opcode(&self) -> Byte {
        16
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetAtomNameRequest {
    pub atom: Atom,
}
impl AsByteSequence for GetAtomNameRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.atom.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (atom, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { atom }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetAtomNameReply {
    pub sequence: Card16,
    pub length: Card32,
    pub name: String,
}
impl AsByteSequence for GetAtomNameReply {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len4225987608, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len4225987608)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                name,
            },
            index,
        ))
    }
}
impl Request for GetAtomNameRequest {
    type Reply = GetAtomNameReply;
    #[inline]
    fn opcode(&self) -> Byte {
        17
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangePropertyRequest {
    pub mode: Card8,
    pub window: Window,
    pub property: Atom,
    pub type_: Atom,
    pub format: Card8,
    pub data_len: Card32,
    pub data: Vec<u8>,
}
impl AsByteSequence for ChangePropertyRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + <Card32>::size()
            + 3
            + <Card8>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index += self.type_.as_bytes(&mut bytes[index..]);
        index += self.format.as_bytes(&mut bytes[index..]);
        index += 3;
        index += self.data_len.as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.data, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (type_, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (format, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        let (data_len, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (data, sz): (Vec<u8>, usize) = vector_from_bytes(
            bytes,
            ((data_len as u16 * format as u16) / format as u16) as Card16,
        )?;
        index += sz;
        Some((
            Self {
                mode,
                window,
                property,
                type_,
                format,
                data_len,
                data,
            },
            index,
        ))
    }
}
impl Request for ChangePropertyRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        18
    }
}
#[derive(Default, Debug, Clone)]
pub struct DeletePropertyRequest {
    pub window: Window,
    pub property: Atom,
}
impl AsByteSequence for DeletePropertyRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window, property }, index))
    }
}
impl Request for DeletePropertyRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        19
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPropertyRequest {
    pub delete: ::std::os::raw::c_char,
    pub window: Window,
    pub property: Atom,
    pub type_: Atom,
    pub long_offset: Card32,
    pub long_length: Card32,
}
impl AsByteSequence for GetPropertyRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card32>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.delete.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index += self.type_.as_bytes(&mut bytes[index..]);
        index += self.long_offset.as_bytes(&mut bytes[index..]);
        index += self.long_length.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (delete, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (type_, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (long_offset, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (long_length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                delete,
                window,
                property,
                type_,
                long_offset,
                long_length,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPropertyReply {
    pub sequence: Card16,
    pub length: Card32,
    pub format: Card8,
    pub type_: Atom,
    pub bytes_after: Card32,
    pub value_len: Card32,
    pub value: Vec<u8>,
}
impl AsByteSequence for GetPropertyReply {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + 12
            + <Card32>::size()
            + <Card32>::size()
            + <Atom>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.format.as_bytes(&mut bytes[index..]);
        index += self.type_.as_bytes(&mut bytes[index..]);
        index += self.bytes_after.as_bytes(&mut bytes[index..]);
        index += self.value_len.as_bytes(&mut bytes[index..]);
        index += 12;
        index += vector_as_bytes(&self.value, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (format, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (type_, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bytes_after, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (value_len, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 12;
        let (value, sz): (Vec<u8>, usize) =
            vector_from_bytes(bytes, (value_len as u16 * (format as u16 / 8)) as Card16)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                format,
                type_,
                bytes_after,
                value_len,
                value,
            },
            index,
        ))
    }
}
impl Request for GetPropertyRequest {
    type Reply = GetPropertyReply;
    #[inline]
    fn opcode(&self) -> Byte {
        20
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListPropertiesRequest {
    pub window: Window,
}
impl AsByteSequence for ListPropertiesRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListPropertiesReply {
    pub sequence: Card16,
    pub length: Card32,
    pub atoms: Vec<Atom>,
}
impl AsByteSequence for ListPropertiesReply {
    #[inline]
    fn size() -> usize {
        <Atom>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.atoms.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.atoms, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len278362269, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (atoms, sz): (Vec<Atom>, usize) = vector_from_bytes(bytes, len278362269)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                atoms,
            },
            index,
        ))
    }
}
impl Request for ListPropertiesRequest {
    type Reply = ListPropertiesReply;
    #[inline]
    fn opcode(&self) -> Byte {
        21
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetSelectionOwnerRequest {
    pub owner: Window,
    pub selection: Atom,
    pub time: Timestamp,
}
impl AsByteSequence for SetSelectionOwnerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.owner.as_bytes(&mut bytes[index..]);
        index += self.selection.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (owner, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                owner,
                selection,
                time,
            },
            index,
        ))
    }
}
impl Request for SetSelectionOwnerRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        22
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetSelectionOwnerRequest {
    pub selection: Atom,
}
impl AsByteSequence for GetSelectionOwnerRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.selection.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { selection }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetSelectionOwnerReply {
    pub sequence: Card16,
    pub length: Card32,
    pub owner: Window,
}
impl AsByteSequence for GetSelectionOwnerReply {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.owner.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (owner, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                owner,
            },
            index,
        ))
    }
}
impl Request for GetSelectionOwnerRequest {
    type Reply = GetSelectionOwnerReply;
    #[inline]
    fn opcode(&self) -> Byte {
        23
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConvertSelectionRequest {
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
    pub time: Timestamp,
}
impl AsByteSequence for ConvertSelectionRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.requestor.as_bytes(&mut bytes[index..]);
        index += self.selection.as_bytes(&mut bytes[index..]);
        index += self.target.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (requestor, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (target, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                requestor,
                selection,
                target,
                property,
                time,
            },
            index,
        ))
    }
}
impl Request for ConvertSelectionRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        24
    }
}
#[derive(Default, Debug, Clone)]
pub struct SendEventRequest {
    pub propagate: ::std::os::raw::c_char,
    pub destination: Window,
    pub event_mask: Card32,
    pub event: [bool; 32],
}
impl AsByteSequence for SendEventRequest {
    #[inline]
    fn size() -> usize {
        <[bool; 32]>::size()
            + <Card32>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.propagate.as_bytes(&mut bytes[index..]);
        index += self.destination.as_bytes(&mut bytes[index..]);
        index += self.event_mask.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (propagate, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (destination, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): ([bool; 32], usize) = <[bool; 32]>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                propagate,
                destination,
                event_mask,
                event,
            },
            index,
        ))
    }
}
impl Request for SendEventRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        25
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabPointerRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub event_mask: Card16,
    pub pointer_mode: Byte,
    pub keyboard_mode: Byte,
    pub confine_to: Window,
    pub cursor: Cursor,
    pub time: Timestamp,
}
impl AsByteSequence for GrabPointerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size()
            + <Cursor>::size()
            + <Window>::size()
            + <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.owner_events.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.event_mask.as_bytes(&mut bytes[index..]);
        index += self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += self.confine_to.as_bytes(&mut bytes[index..]);
        index += self.cursor.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (owner_events, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pointer_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keyboard_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (confine_to, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (cursor, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                owner_events,
                grab_window,
                event_mask,
                pointer_mode,
                keyboard_mode,
                confine_to,
                cursor,
                time,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabPointerReply {
    pub sequence: Card16,
    pub length: Card32,
    pub status: Byte,
}
impl AsByteSequence for GrabPointerReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.status.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (status, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                status,
            },
            index,
        ))
    }
}
impl Request for GrabPointerRequest {
    type Reply = GrabPointerReply;
    #[inline]
    fn opcode(&self) -> Byte {
        26
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabPointerRequest {
    pub time: Timestamp,
}
impl AsByteSequence for UngrabPointerRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { time }, index))
    }
}
impl Request for UngrabPointerRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        27
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabButtonRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub event_mask: Card16,
    pub pointer_mode: Card8,
    pub keyboard_mode: Card8,
    pub confine_to: Window,
    pub cursor: Cursor,
    pub button: Card8,
    pub modifiers: Card16,
}
impl AsByteSequence for GrabButtonRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + 1
            + <Card8>::size()
            + <Cursor>::size()
            + <Window>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.owner_events.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.event_mask.as_bytes(&mut bytes[index..]);
        index += self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += self.confine_to.as_bytes(&mut bytes[index..]);
        index += self.cursor.as_bytes(&mut bytes[index..]);
        index += self.button.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.modifiers.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (owner_events, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pointer_mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keyboard_mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (confine_to, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (cursor, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (button, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (modifiers, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                owner_events,
                grab_window,
                event_mask,
                pointer_mode,
                keyboard_mode,
                confine_to,
                cursor,
                button,
                modifiers,
            },
            index,
        ))
    }
}
impl Request for GrabButtonRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        28
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabButtonRequest {
    pub button: Card8,
    pub grab_window: Window,
    pub modifiers: Card16,
}
impl AsByteSequence for UngrabButtonRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.button.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.modifiers.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (button, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (modifiers, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                button,
                grab_window,
                modifiers,
            },
            index,
        ))
    }
}
impl Request for UngrabButtonRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        29
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeActivePointerGrabRequest {
    pub cursor: Cursor,
    pub time: Timestamp,
    pub event_mask: Card16,
}
impl AsByteSequence for ChangeActivePointerGrabRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Timestamp>::size() + <Cursor>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cursor.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.event_mask.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cursor, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                cursor,
                time,
                event_mask,
            },
            index,
        ))
    }
}
impl Request for ChangeActivePointerGrabRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        30
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyboardRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub time: Timestamp,
    pub pointer_mode: Byte,
    pub keyboard_mode: Byte,
}
impl AsByteSequence for GrabKeyboardRequest {
    #[inline]
    fn size() -> usize {
        2 + <Byte>::size()
            + <Byte>::size()
            + <Timestamp>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.owner_events.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (owner_events, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pointer_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keyboard_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                owner_events,
                grab_window,
                time,
                pointer_mode,
                keyboard_mode,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyboardReply {
    pub sequence: Card16,
    pub length: Card32,
    pub status: Byte,
}
impl AsByteSequence for GrabKeyboardReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.status.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (status, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                status,
            },
            index,
        ))
    }
}
impl Request for GrabKeyboardRequest {
    type Reply = GrabKeyboardReply;
    #[inline]
    fn opcode(&self) -> Byte {
        31
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabKeyboardRequest {
    pub time: Timestamp,
}
impl AsByteSequence for UngrabKeyboardRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { time }, index))
    }
}
impl Request for UngrabKeyboardRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        32
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabKeyRequest {
    pub owner_events: ::std::os::raw::c_char,
    pub grab_window: Window,
    pub modifiers: Card16,
    pub key: Keycode,
    pub pointer_mode: Card8,
    pub keyboard_mode: Card8,
}
impl AsByteSequence for GrabKeyRequest {
    #[inline]
    fn size() -> usize {
        3 + <Card8>::size()
            + <Card8>::size()
            + <Keycode>::size()
            + <Card16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.owner_events.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.modifiers.as_bytes(&mut bytes[index..]);
        index += self.key.as_bytes(&mut bytes[index..]);
        index += self.pointer_mode.as_bytes(&mut bytes[index..]);
        index += self.keyboard_mode.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (owner_events, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (modifiers, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (key, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pointer_mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keyboard_mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                owner_events,
                grab_window,
                modifiers,
                key,
                pointer_mode,
                keyboard_mode,
            },
            index,
        ))
    }
}
impl Request for GrabKeyRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        33
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabKeyRequest {
    pub key: Keycode,
    pub grab_window: Window,
    pub modifiers: Card16,
}
impl AsByteSequence for UngrabKeyRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Window>::size() + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.key.as_bytes(&mut bytes[index..]);
        index += self.grab_window.as_bytes(&mut bytes[index..]);
        index += self.modifiers.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (key, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (grab_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (modifiers, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                key,
                grab_window,
                modifiers,
            },
            index,
        ))
    }
}
impl Request for UngrabKeyRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        34
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllowEventsRequest {
    pub mode: Card8,
    pub time: Timestamp,
}
impl AsByteSequence for AllowEventsRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mode, time }, index))
    }
}
impl Request for AllowEventsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        35
    }
}
#[derive(Default, Debug, Clone)]
pub struct GrabServerRequest;
impl AsByteSequence for GrabServerRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
impl Request for GrabServerRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        36
    }
}
#[derive(Default, Debug, Clone)]
pub struct UngrabServerRequest;
impl AsByteSequence for UngrabServerRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
impl Request for UngrabServerRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        37
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryPointerRequest {
    pub window: Window,
}
impl AsByteSequence for QueryPointerRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryPointerReply {
    pub sequence: Card16,
    pub length: Card32,
    pub same_screen: ::std::os::raw::c_char,
    pub root: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub win_x: Int16,
    pub win_y: Int16,
    pub mask: Card16,
}
impl AsByteSequence for QueryPointerReply {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.win_x.as_bytes(&mut bytes[index..]);
        index += self.win_y.as_bytes(&mut bytes[index..]);
        index += self.mask.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (win_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (win_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                sequence,
                length,
                same_screen,
                root,
                child,
                root_x,
                root_y,
                win_x,
                win_y,
                mask,
            },
            index,
        ))
    }
}
impl Request for QueryPointerRequest {
    type Reply = QueryPointerReply;
    #[inline]
    fn opcode(&self) -> Byte {
        38
    }
}
#[derive(Default, Debug, Clone)]
pub struct Timecoord {
    pub time: Timestamp,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for Timecoord {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Timestamp>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { time, x, y }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetMotionEventsRequest {
    pub window: Window,
    pub start: Timestamp,
    pub stop: Timestamp,
}
impl AsByteSequence for GetMotionEventsRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Timestamp>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.start.as_bytes(&mut bytes[index..]);
        index += self.stop.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (start, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (stop, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                window,
                start,
                stop,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetMotionEventsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub events: Vec<Timecoord>,
}
impl AsByteSequence for GetMotionEventsReply {
    #[inline]
    fn size() -> usize {
        <Timecoord>::size() * 32 + 20 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.events.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 20;
        index += vector_as_bytes(&self.events, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len1277880020, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 20;
        let (events, sz): (Vec<Timecoord>, usize) = vector_from_bytes(bytes, len1277880020)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                events,
            },
            index,
        ))
    }
}
impl Request for GetMotionEventsRequest {
    type Reply = GetMotionEventsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        39
    }
}
#[derive(Default, Debug, Clone)]
pub struct TranslateCoordinatesRequest {
    pub src_window: Window,
    pub dst_window: Window,
    pub src_x: Int16,
    pub src_y: Int16,
}
impl AsByteSequence for TranslateCoordinatesRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.src_window.as_bytes(&mut bytes[index..]);
        index += self.dst_window.as_bytes(&mut bytes[index..]);
        index += self.src_x.as_bytes(&mut bytes[index..]);
        index += self.src_y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (src_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                src_window,
                dst_window,
                src_x,
                src_y,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct TranslateCoordinatesReply {
    pub sequence: Card16,
    pub length: Card32,
    pub same_screen: ::std::os::raw::c_char,
    pub child: Window,
    pub dst_x: Int16,
    pub dst_y: Int16,
}
impl AsByteSequence for TranslateCoordinatesReply {
    #[inline]
    fn size() -> usize {
        <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.dst_x.as_bytes(&mut bytes[index..]);
        index += self.dst_y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                same_screen,
                child,
                dst_x,
                dst_y,
            },
            index,
        ))
    }
}
impl Request for TranslateCoordinatesRequest {
    type Reply = TranslateCoordinatesReply;
    #[inline]
    fn opcode(&self) -> Byte {
        40
    }
}
#[derive(Default, Debug, Clone)]
pub struct WarpPointerRequest {
    pub src_window: Window,
    pub dst_window: Window,
    pub src_x: Int16,
    pub src_y: Int16,
    pub src_width: Card16,
    pub src_height: Card16,
    pub dst_x: Int16,
    pub dst_y: Int16,
}
impl AsByteSequence for WarpPointerRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.src_window.as_bytes(&mut bytes[index..]);
        index += self.dst_window.as_bytes(&mut bytes[index..]);
        index += self.src_x.as_bytes(&mut bytes[index..]);
        index += self.src_y.as_bytes(&mut bytes[index..]);
        index += self.src_width.as_bytes(&mut bytes[index..]);
        index += self.src_height.as_bytes(&mut bytes[index..]);
        index += self.dst_x.as_bytes(&mut bytes[index..]);
        index += self.dst_y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (src_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                src_window,
                dst_window,
                src_x,
                src_y,
                src_width,
                src_height,
                dst_x,
                dst_y,
            },
            index,
        ))
    }
}
impl Request for WarpPointerRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        41
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetInputFocusRequest {
    pub revert_to: Card8,
    pub focus: Window,
    pub time: Timestamp,
}
impl AsByteSequence for SetInputFocusRequest {
    #[inline]
    fn size() -> usize {
        <Timestamp>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.revert_to.as_bytes(&mut bytes[index..]);
        index += self.focus.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (revert_to, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (focus, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                revert_to,
                focus,
                time,
            },
            index,
        ))
    }
}
impl Request for SetInputFocusRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        42
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetInputFocusRequest;
impl AsByteSequence for GetInputFocusRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetInputFocusReply {
    pub sequence: Card16,
    pub length: Card32,
    pub revert_to: Card8,
    pub focus: Window,
}
impl AsByteSequence for GetInputFocusReply {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Card8>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.revert_to.as_bytes(&mut bytes[index..]);
        index += self.focus.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (revert_to, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (focus, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                revert_to,
                focus,
            },
            index,
        ))
    }
}
impl Request for GetInputFocusRequest {
    type Reply = GetInputFocusReply;
    #[inline]
    fn opcode(&self) -> Byte {
        43
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryKeymapRequest;
impl AsByteSequence for QueryKeymapRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryKeymapReply {
    pub sequence: Card16,
    pub length: Card32,
    pub keys: [Card8; 32],
}
impl AsByteSequence for QueryKeymapReply {
    #[inline]
    fn size() -> usize {
        <[Card8; 32]>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.keys.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (keys, sz): ([Card8; 32], usize) = <[Card8; 32]>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                keys,
            },
            index,
        ))
    }
}
impl Request for QueryKeymapRequest {
    type Reply = QueryKeymapReply;
    #[inline]
    fn opcode(&self) -> Byte {
        44
    }
}
#[derive(Default, Debug, Clone)]
pub struct OpenFontRequest {
    pub fid: Font,
    pub name: String,
}
impl AsByteSequence for OpenFontRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + <Font>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.fid.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (fid, sz): (Font, usize) = <Font>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len2204872268, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len2204872268)?;
        index += sz;
        Some((Self { fid, name }, index))
    }
}
impl Request for OpenFontRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        45
    }
}
#[derive(Default, Debug, Clone)]
pub struct CloseFontRequest {
    pub font: Font,
}
impl AsByteSequence for CloseFontRequest {
    #[inline]
    fn size() -> usize {
        <Font>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.font.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (font, sz): (Font, usize) = <Font>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { font }, index))
    }
}
impl Request for CloseFontRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        46
    }
}
#[derive(Default, Debug, Clone)]
pub struct Fontprop {
    pub name: Atom,
    pub value: Card32,
}
impl AsByteSequence for Fontprop {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Atom>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.name.as_bytes(&mut bytes[index..]);
        index += self.value.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (name, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (value, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { name, value }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct Charinfo {
    pub left_side_bearing: Int16,
    pub right_side_bearing: Int16,
    pub character_width: Int16,
    pub ascent: Int16,
    pub descent: Int16,
    pub attributes: Card16,
}
impl AsByteSequence for Charinfo {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.left_side_bearing.as_bytes(&mut bytes[index..]);
        index += self.right_side_bearing.as_bytes(&mut bytes[index..]);
        index += self.character_width.as_bytes(&mut bytes[index..]);
        index += self.ascent.as_bytes(&mut bytes[index..]);
        index += self.descent.as_bytes(&mut bytes[index..]);
        index += self.attributes.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (left_side_bearing, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (right_side_bearing, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (character_width, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (ascent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (descent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (attributes, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                left_side_bearing,
                right_side_bearing,
                character_width,
                ascent,
                descent,
                attributes,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryFontRequest {
    pub font: Fontable,
}
impl AsByteSequence for QueryFontRequest {
    #[inline]
    fn size() -> usize {
        <Fontable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.font.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (font, sz): (Fontable, usize) = <Fontable>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { font }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryFontReply {
    pub sequence: Card16,
    pub length: Card32,
    pub min_bounds: Charinfo,
    pub max_bounds: Charinfo,
    pub min_char_or_byteTwo: Card16,
    pub max_char_or_byteTwo: Card16,
    pub default_char: Card16,
    pub draw_direction: Byte,
    pub min_byteOne: Card8,
    pub max_byteOne: Card8,
    pub all_chars_exist: ::std::os::raw::c_char,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub properties: Vec<Fontprop>,
    pub char_infos: Vec<Charinfo>,
}
impl AsByteSequence for QueryFontReply {
    #[inline]
    fn size() -> usize {
        <Charinfo>::size() * 32
            + <Fontprop>::size() * 32
            + 2
            + <Int16>::size()
            + <Int16>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Byte>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 4
            + <Charinfo>::size()
            + 4
            + <Charinfo>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.min_bounds.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.max_bounds.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.min_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += self.max_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += self.default_char.as_bytes(&mut bytes[index..]);
        index += (self.properties.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.draw_direction.as_bytes(&mut bytes[index..]);
        index += self.min_byteOne.as_bytes(&mut bytes[index..]);
        index += self.max_byteOne.as_bytes(&mut bytes[index..]);
        index += self.all_chars_exist.as_bytes(&mut bytes[index..]);
        index += self.font_ascent.as_bytes(&mut bytes[index..]);
        index += self.font_descent.as_bytes(&mut bytes[index..]);
        index += (self.char_infos.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.properties, &mut bytes[index..]);
        index += vector_as_bytes(&self.char_infos, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (min_bounds, sz): (Charinfo, usize) = <Charinfo>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (max_bounds, sz): (Charinfo, usize) = <Charinfo>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (min_char_or_byteTwo, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_char_or_byteTwo, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (default_char, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len880796050, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (draw_direction, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (min_byteOne, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_byteOne, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (all_chars_exist, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_ascent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_descent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3693503700, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (properties, sz): (Vec<Fontprop>, usize) = vector_from_bytes(bytes, len880796050)?;
        index += sz;
        let (char_infos, sz): (Vec<Charinfo>, usize) = vector_from_bytes(bytes, len3693503700)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                min_bounds,
                max_bounds,
                min_char_or_byteTwo,
                max_char_or_byteTwo,
                default_char,
                draw_direction,
                min_byteOne,
                max_byteOne,
                all_chars_exist,
                font_ascent,
                font_descent,
                properties,
                char_infos,
            },
            index,
        ))
    }
}
impl Request for QueryFontRequest {
    type Reply = QueryFontReply;
    #[inline]
    fn opcode(&self) -> Byte {
        47
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTextExtentsRequest {
    pub font: Fontable,
}
impl AsByteSequence for QueryTextExtentsRequest {
    #[inline]
    fn size() -> usize {
        <Fontable>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.font.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (font, sz): (Fontable, usize) = <Fontable>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { font }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryTextExtentsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub draw_direction: Byte,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub overall_ascent: Int16,
    pub overall_descent: Int16,
    pub overall_width: Int32,
    pub overall_left: Int32,
    pub overall_right: Int32,
}
impl AsByteSequence for QueryTextExtentsReply {
    #[inline]
    fn size() -> usize {
        <Int32>::size()
            + <Int32>::size()
            + <Int32>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Byte>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.draw_direction.as_bytes(&mut bytes[index..]);
        index += self.font_ascent.as_bytes(&mut bytes[index..]);
        index += self.font_descent.as_bytes(&mut bytes[index..]);
        index += self.overall_ascent.as_bytes(&mut bytes[index..]);
        index += self.overall_descent.as_bytes(&mut bytes[index..]);
        index += self.overall_width.as_bytes(&mut bytes[index..]);
        index += self.overall_left.as_bytes(&mut bytes[index..]);
        index += self.overall_right.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (draw_direction, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_ascent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_descent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (overall_ascent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (overall_descent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (overall_width, sz): (Int32, usize) = <Int32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (overall_left, sz): (Int32, usize) = <Int32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (overall_right, sz): (Int32, usize) = <Int32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                draw_direction,
                font_ascent,
                font_descent,
                overall_ascent,
                overall_descent,
                overall_width,
                overall_left,
                overall_right,
            },
            index,
        ))
    }
}
impl Request for QueryTextExtentsRequest {
    type Reply = QueryTextExtentsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        48
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsRequest {
    pub max_names: Card16,
    pub pattern: String,
}
impl AsByteSequence for ListFontsRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.max_names.as_bytes(&mut bytes[index..]);
        index += (self.pattern.len() as Card16).as_bytes(&mut bytes[index..]);
        index += string_as_bytes(&self.pattern, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (max_names, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len2186877739, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pattern, sz): (String, usize) = string_from_bytes(bytes, len2186877739)?;
        index += sz;
        Some((Self { max_names, pattern }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub names: Vec<String>,
}
impl AsByteSequence for ListFontsReply {
    #[inline]
    fn size() -> usize {
        <String>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.names.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.names, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len206553957, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (names, sz): (Vec<String>, usize) = vector_from_bytes(bytes, len206553957)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                names,
            },
            index,
        ))
    }
}
impl Request for ListFontsRequest {
    type Reply = ListFontsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        49
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsWithInfoRequest {
    pub max_names: Card16,
    pub pattern: String,
}
impl AsByteSequence for ListFontsWithInfoRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + <Card16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.max_names.as_bytes(&mut bytes[index..]);
        index += (self.pattern.len() as Card16).as_bytes(&mut bytes[index..]);
        index += string_as_bytes(&self.pattern, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (max_names, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3965797538, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pattern, sz): (String, usize) = string_from_bytes(bytes, len3965797538)?;
        index += sz;
        Some((Self { max_names, pattern }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListFontsWithInfoReply {
    pub sequence: Card16,
    pub length: Card32,
    pub min_bounds: Charinfo,
    pub max_bounds: Charinfo,
    pub min_char_or_byteTwo: Card16,
    pub max_char_or_byteTwo: Card16,
    pub default_char: Card16,
    pub draw_direction: Byte,
    pub min_byteOne: Card8,
    pub max_byteOne: Card8,
    pub all_chars_exist: ::std::os::raw::c_char,
    pub font_ascent: Int16,
    pub font_descent: Int16,
    pub replies_hint: Card32,
    pub properties: Vec<Fontprop>,
    pub name: String,
}
impl AsByteSequence for ListFontsWithInfoReply {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + <Fontprop>::size() * 32
            + <Card32>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <::std::os::raw::c_char>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Byte>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 4
            + <Charinfo>::size()
            + 4
            + <Charinfo>::size()
            + 2
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.min_bounds.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.max_bounds.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.min_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += self.max_char_or_byteTwo.as_bytes(&mut bytes[index..]);
        index += self.default_char.as_bytes(&mut bytes[index..]);
        index += (self.properties.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.draw_direction.as_bytes(&mut bytes[index..]);
        index += self.min_byteOne.as_bytes(&mut bytes[index..]);
        index += self.max_byteOne.as_bytes(&mut bytes[index..]);
        index += self.all_chars_exist.as_bytes(&mut bytes[index..]);
        index += self.font_ascent.as_bytes(&mut bytes[index..]);
        index += self.font_descent.as_bytes(&mut bytes[index..]);
        index += self.replies_hint.as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.properties, &mut bytes[index..]);
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len1586737979, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (min_bounds, sz): (Charinfo, usize) = <Charinfo>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (max_bounds, sz): (Charinfo, usize) = <Charinfo>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (min_char_or_byteTwo, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_char_or_byteTwo, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (default_char, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len696835951, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (draw_direction, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (min_byteOne, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (max_byteOne, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (all_chars_exist, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_ascent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (font_descent, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (replies_hint, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (properties, sz): (Vec<Fontprop>, usize) = vector_from_bytes(bytes, len696835951)?;
        index += sz;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len1586737979)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                min_bounds,
                max_bounds,
                min_char_or_byteTwo,
                max_char_or_byteTwo,
                default_char,
                draw_direction,
                min_byteOne,
                max_byteOne,
                all_chars_exist,
                font_ascent,
                font_descent,
                replies_hint,
                properties,
                name,
            },
            index,
        ))
    }
}
impl Request for ListFontsWithInfoRequest {
    type Reply = ListFontsWithInfoReply;
    #[inline]
    fn opcode(&self) -> Byte {
        50
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetFontPathRequest {
    pub font: Vec<String>,
}
impl AsByteSequence for SetFontPathRequest {
    #[inline]
    fn size() -> usize {
        <String>::size() * 32 + 2 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += (self.font.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += vector_as_bytes(&self.font, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (len2393895031, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (font, sz): (Vec<String>, usize) = vector_from_bytes(bytes, len2393895031)?;
        index += sz;
        Some((Self { font }, index))
    }
}
impl Request for SetFontPathRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        51
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetFontPathRequest;
impl AsByteSequence for GetFontPathRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetFontPathReply {
    pub sequence: Card16,
    pub length: Card32,
    pub path: Vec<String>,
}
impl AsByteSequence for GetFontPathReply {
    #[inline]
    fn size() -> usize {
        <String>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.path.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.path, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len4184801594, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (path, sz): (Vec<String>, usize) = vector_from_bytes(bytes, len4184801594)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                path,
            },
            index,
        ))
    }
}
impl Request for GetFontPathRequest {
    type Reply = GetFontPathReply;
    #[inline]
    fn opcode(&self) -> Byte {
        52
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreatePixmapRequest {
    pub depth: Card8,
    pub pid: Pixmap,
    pub drawable: Drawable,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for CreatePixmapRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Drawable>::size()
            + <Pixmap>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += self.pid.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pid, sz): (Pixmap, usize) = <Pixmap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                depth,
                pid,
                drawable,
                width,
                height,
            },
            index,
        ))
    }
}
impl Request for CreatePixmapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        53
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreePixmapRequest {
    pub pixmap: Pixmap,
}
impl AsByteSequence for FreePixmapRequest {
    #[inline]
    fn size() -> usize {
        <Pixmap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.pixmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (pixmap, sz): (Pixmap, usize) = <Pixmap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { pixmap }, index))
    }
}
impl Request for FreePixmapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        54
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateGCRequest {
    pub cid: Gcontext,
    pub drawable: Drawable,
}
impl AsByteSequence for CreateGCRequest {
    #[inline]
    fn size() -> usize {
        <Drawable>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cid.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cid, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cid, drawable }, index))
    }
}
impl Request for CreateGCRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        55
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeGCRequest {
    pub gc: Gcontext,
}
impl AsByteSequence for ChangeGCRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { gc }, index))
    }
}
impl Request for ChangeGCRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        56
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyGCRequest {
    pub src_gc: Gcontext,
    pub dst_gc: Gcontext,
    pub value_mask: Card32,
}
impl AsByteSequence for CopyGCRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Gcontext>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.src_gc.as_bytes(&mut bytes[index..]);
        index += self.dst_gc.as_bytes(&mut bytes[index..]);
        index += self.value_mask.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (src_gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (value_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                src_gc,
                dst_gc,
                value_mask,
            },
            index,
        ))
    }
}
impl Request for CopyGCRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        57
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetDashesRequest {
    pub gc: Gcontext,
    pub dash_offset: Card16,
    pub dashes: Vec<Card8>,
}
impl AsByteSequence for SetDashesRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() * 32 + 2 + <Card16>::size() + <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.dash_offset.as_bytes(&mut bytes[index..]);
        index += (self.dashes.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.dashes, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dash_offset, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len663756733, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dashes, sz): (Vec<Card8>, usize) = vector_from_bytes(bytes, len663756733)?;
        index += sz;
        Some((
            Self {
                gc,
                dash_offset,
                dashes,
            },
            index,
        ))
    }
}
impl Request for SetDashesRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        58
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetClipRectanglesRequest {
    pub ordering: Byte,
    pub gc: Gcontext,
    pub clip_x_origin: Int16,
    pub clip_y_origin: Int16,
}
impl AsByteSequence for SetClipRectanglesRequest {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.ordering.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.clip_x_origin.as_bytes(&mut bytes[index..]);
        index += self.clip_y_origin.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (ordering, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (clip_x_origin, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (clip_y_origin, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                ordering,
                gc,
                clip_x_origin,
                clip_y_origin,
            },
            index,
        ))
    }
}
impl Request for SetClipRectanglesRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        59
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeGCRequest {
    pub gc: Gcontext,
}
impl AsByteSequence for FreeGCRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { gc }, index))
    }
}
impl Request for FreeGCRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        60
    }
}
#[derive(Default, Debug, Clone)]
pub struct ClearAreaRequest {
    pub exposures: ::std::os::raw::c_char,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for ClearAreaRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.exposures.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (exposures, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                exposures,
                window,
                x,
                y,
                width,
                height,
            },
            index,
        ))
    }
}
impl Request for ClearAreaRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        61
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyAreaRequest {
    pub src_drawable: Drawable,
    pub dst_drawable: Drawable,
    pub gc: Gcontext,
    pub src_x: Int16,
    pub src_y: Int16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for CopyAreaRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.src_drawable.as_bytes(&mut bytes[index..]);
        index += self.dst_drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.src_x.as_bytes(&mut bytes[index..]);
        index += self.src_y.as_bytes(&mut bytes[index..]);
        index += self.dst_x.as_bytes(&mut bytes[index..]);
        index += self.dst_y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (src_drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                src_drawable,
                dst_drawable,
                gc,
                src_x,
                src_y,
                dst_x,
                dst_y,
                width,
                height,
            },
            index,
        ))
    }
}
impl Request for CopyAreaRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        62
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyPlaneRequest {
    pub src_drawable: Drawable,
    pub dst_drawable: Drawable,
    pub gc: Gcontext,
    pub src_x: Int16,
    pub src_y: Int16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub bit_plane: Card32,
}
impl AsByteSequence for CopyPlaneRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.src_drawable.as_bytes(&mut bytes[index..]);
        index += self.dst_drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.src_x.as_bytes(&mut bytes[index..]);
        index += self.src_y.as_bytes(&mut bytes[index..]);
        index += self.dst_x.as_bytes(&mut bytes[index..]);
        index += self.dst_y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.bit_plane.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (src_drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bit_plane, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                src_drawable,
                dst_drawable,
                gc,
                src_x,
                src_y,
                dst_x,
                dst_y,
                width,
                height,
                bit_plane,
            },
            index,
        ))
    }
}
impl Request for CopyPlaneRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        63
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyPointRequest {
    pub coordinate_mode: Byte,
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyPointRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (coordinate_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                coordinate_mode,
                drawable,
                gc,
            },
            index,
        ))
    }
}
impl Request for PolyPointRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        64
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyLineRequest {
    pub coordinate_mode: Byte,
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyLineRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (coordinate_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                coordinate_mode,
                drawable,
                gc,
            },
            index,
        ))
    }
}
impl Request for PolyLineRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        65
    }
}
#[derive(Default, Debug, Clone)]
pub struct Segment {
    pub xOne: Int16,
    pub yOne: Int16,
    pub xTwo: Int16,
    pub yTwo: Int16,
}
impl AsByteSequence for Segment {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Int16>::size() + <Int16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.xOne.as_bytes(&mut bytes[index..]);
        index += self.yOne.as_bytes(&mut bytes[index..]);
        index += self.xTwo.as_bytes(&mut bytes[index..]);
        index += self.yTwo.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (xOne, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (yOne, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (xTwo, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (yTwo, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                xOne,
                yOne,
                xTwo,
                yTwo,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolySegmentRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolySegmentRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc }, index))
    }
}
impl Request for PolySegmentRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        66
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyRectangleRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyRectangleRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc }, index))
    }
}
impl Request for PolyRectangleRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        67
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyArcRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyArcRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc }, index))
    }
}
impl Request for PolyArcRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        68
    }
}
#[derive(Default, Debug, Clone)]
pub struct FillPolyRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub shape: Card8,
    pub coordinate_mode: Card8,
}
impl AsByteSequence for FillPolyRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card8>::size() + <Card8>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.shape.as_bytes(&mut bytes[index..]);
        index += self.coordinate_mode.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (shape, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (coordinate_mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                drawable,
                gc,
                shape,
                coordinate_mode,
            },
            index,
        ))
    }
}
impl Request for FillPolyRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        69
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyFillRectangleRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyFillRectangleRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc }, index))
    }
}
impl Request for PolyFillRectangleRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        70
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyFillArcRequest {
    pub drawable: Drawable,
    pub gc: Gcontext,
}
impl AsByteSequence for PolyFillArcRequest {
    #[inline]
    fn size() -> usize {
        <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc }, index))
    }
}
impl Request for PolyFillArcRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        71
    }
}
#[derive(Default, Debug, Clone)]
pub struct PutImageRequest {
    pub format: Card8,
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub width: Card16,
    pub height: Card16,
    pub dst_x: Int16,
    pub dst_y: Int16,
    pub left_pad: Card8,
    pub depth: Card8,
}
impl AsByteSequence for PutImageRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card8>::size()
            + <Card8>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.format.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.dst_x.as_bytes(&mut bytes[index..]);
        index += self.dst_y.as_bytes(&mut bytes[index..]);
        index += self.left_pad.as_bytes(&mut bytes[index..]);
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (format, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (dst_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (left_pad, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                format,
                drawable,
                gc,
                width,
                height,
                dst_x,
                dst_y,
                left_pad,
                depth,
            },
            index,
        ))
    }
}
impl Request for PutImageRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        72
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetImageRequest {
    pub format: Card8,
    pub drawable: Drawable,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub plane_mask: Card32,
}
impl AsByteSequence for GetImageRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Drawable>::size()
            + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.format.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.plane_mask.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (format, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (plane_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                format,
                drawable,
                x,
                y,
                width,
                height,
                plane_mask,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetImageReply {
    pub sequence: Card16,
    pub length: Card32,
    pub depth: Card8,
    pub visual: Visualid,
    pub data: Vec<Byte>,
}
impl AsByteSequence for GetImageReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size() * 32
            + 20
            + <Visualid>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.depth.as_bytes(&mut bytes[index..]);
        index += self.visual.as_bytes(&mut bytes[index..]);
        index += 20;
        index += vector_as_bytes(&self.data, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (depth, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 20;
        let (data, sz): (Vec<Byte>, usize) =
            vector_from_bytes(bytes, (length as u16 * 4) as Card16)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                depth,
                visual,
                data,
            },
            index,
        ))
    }
}
impl Request for GetImageRequest {
    type Reply = GetImageReply;
    #[inline]
    fn opcode(&self) -> Byte {
        73
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyText8Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for PolyText8Request {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc, x, y }, index))
    }
}
impl Request for PolyText8Request {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        74
    }
}
#[derive(Default, Debug, Clone)]
pub struct PolyText16Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for PolyText16Request {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Gcontext>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { drawable, gc, x, y }, index))
    }
}
impl Request for PolyText16Request {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        75
    }
}
#[derive(Default, Debug, Clone)]
pub struct ImageText8Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
    pub string: String,
}
impl AsByteSequence for ImageText8Request {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += (self.string.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += string_as_bytes(&self.string, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (len867320123, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (string, sz): (String, usize) = string_from_bytes(bytes, len867320123)?;
        index += sz;
        Some((
            Self {
                drawable,
                gc,
                x,
                y,
                string,
            },
            index,
        ))
    }
}
impl Request for ImageText8Request {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        76
    }
}
#[derive(Default, Debug, Clone)]
pub struct ImageText16Request {
    pub drawable: Drawable,
    pub gc: Gcontext,
    pub x: Int16,
    pub y: Int16,
    pub string: Vec<Char2b>,
}
impl AsByteSequence for ImageText16Request {
    #[inline]
    fn size() -> usize {
        <Char2b>::size() * 32
            + <Int16>::size()
            + <Int16>::size()
            + <Gcontext>::size()
            + <Drawable>::size()
            + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += (self.string.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.gc.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.string, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (len1172883267, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (gc, sz): (Gcontext, usize) = <Gcontext>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (string, sz): (Vec<Char2b>, usize) = vector_from_bytes(bytes, len1172883267)?;
        index += sz;
        Some((
            Self {
                drawable,
                gc,
                x,
                y,
                string,
            },
            index,
        ))
    }
}
impl Request for ImageText16Request {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        77
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateColormapRequest {
    pub alloc: Byte,
    pub mid: Colormap,
    pub window: Window,
    pub visual: Visualid,
}
impl AsByteSequence for CreateColormapRequest {
    #[inline]
    fn size() -> usize {
        <Visualid>::size() + <Window>::size() + <Colormap>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.alloc.as_bytes(&mut bytes[index..]);
        index += self.mid.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.visual.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (alloc, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mid, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual, sz): (Visualid, usize) = <Visualid>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                alloc,
                mid,
                window,
                visual,
            },
            index,
        ))
    }
}
impl Request for CreateColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        78
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for FreeColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap }, index))
    }
}
impl Request for FreeColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        79
    }
}
#[derive(Default, Debug, Clone)]
pub struct CopyColormapAndFreeRequest {
    pub mid: Colormap,
    pub src_cmap: Colormap,
}
impl AsByteSequence for CopyColormapAndFreeRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.mid.as_bytes(&mut bytes[index..]);
        index += self.src_cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (mid, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (src_cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mid, src_cmap }, index))
    }
}
impl Request for CopyColormapAndFreeRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        80
    }
}
#[derive(Default, Debug, Clone)]
pub struct InstallColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for InstallColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap }, index))
    }
}
impl Request for InstallColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        81
    }
}
#[derive(Default, Debug, Clone)]
pub struct UninstallColormapRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for UninstallColormapRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap }, index))
    }
}
impl Request for UninstallColormapRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        82
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListInstalledColormapsRequest {
    pub window: Window,
}
impl AsByteSequence for ListInstalledColormapsRequest {
    #[inline]
    fn size() -> usize {
        <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListInstalledColormapsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub cmaps: Vec<Colormap>,
}
impl AsByteSequence for ListInstalledColormapsReply {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.cmaps.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.cmaps, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len4184348918, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (cmaps, sz): (Vec<Colormap>, usize) = vector_from_bytes(bytes, len4184348918)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                cmaps,
            },
            index,
        ))
    }
}
impl Request for ListInstalledColormapsRequest {
    type Reply = ListInstalledColormapsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        83
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorRequest {
    pub cmap: Colormap,
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
}
impl AsByteSequence for AllocColorRequest {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Card16>::size() + <Card16>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += self.red.as_bytes(&mut bytes[index..]);
        index += self.green.as_bytes(&mut bytes[index..]);
        index += self.blue.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                cmap,
                red,
                green,
                blue,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorReply {
    pub sequence: Card16,
    pub length: Card32,
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
    pub pixel: Card32,
}
impl AsByteSequence for AllocColorReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.red.as_bytes(&mut bytes[index..]);
        index += self.green.as_bytes(&mut bytes[index..]);
        index += self.blue.as_bytes(&mut bytes[index..]);
        index += 2;
        index += self.pixel.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                red,
                green,
                blue,
                pixel,
            },
            index,
        ))
    }
}
impl Request for AllocColorRequest {
    type Reply = AllocColorReply;
    #[inline]
    fn opcode(&self) -> Byte {
        84
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocNamedColorRequest {
    pub cmap: Colormap,
    pub name: String,
}
impl AsByteSequence for AllocNamedColorRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len760116259, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len760116259)?;
        index += sz;
        Some((Self { cmap, name }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocNamedColorReply {
    pub sequence: Card16,
    pub length: Card32,
    pub pixel: Card32,
    pub exact_red: Card16,
    pub exact_green: Card16,
    pub exact_blue: Card16,
    pub visual_red: Card16,
    pub visual_green: Card16,
    pub visual_blue: Card16,
}
impl AsByteSequence for AllocNamedColorReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.pixel.as_bytes(&mut bytes[index..]);
        index += self.exact_red.as_bytes(&mut bytes[index..]);
        index += self.exact_green.as_bytes(&mut bytes[index..]);
        index += self.exact_blue.as_bytes(&mut bytes[index..]);
        index += self.visual_red.as_bytes(&mut bytes[index..]);
        index += self.visual_green.as_bytes(&mut bytes[index..]);
        index += self.visual_blue.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (exact_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (exact_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (exact_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                pixel,
                exact_red,
                exact_green,
                exact_blue,
                visual_red,
                visual_green,
                visual_blue,
            },
            index,
        ))
    }
}
impl Request for AllocNamedColorRequest {
    type Reply = AllocNamedColorReply;
    #[inline]
    fn opcode(&self) -> Byte {
        85
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorCellsRequest {
    pub contiguous: ::std::os::raw::c_char,
    pub cmap: Colormap,
    pub colors: Card16,
    pub planes: Card16,
}
impl AsByteSequence for AllocColorCellsRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Colormap>::size() + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.contiguous.as_bytes(&mut bytes[index..]);
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += self.colors.as_bytes(&mut bytes[index..]);
        index += self.planes.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (contiguous, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (colors, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (planes, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                contiguous,
                cmap,
                colors,
                planes,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorCellsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub pixels: Vec<Card32>,
    pub masks: Vec<Card32>,
}
impl AsByteSequence for AllocColorCellsReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size() * 32
            + <Card32>::size() * 32
            + 20
            + 2
            + 2
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.pixels.len() as Card16).as_bytes(&mut bytes[index..]);
        index += (self.masks.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 20;
        index += vector_as_bytes(&self.pixels, &mut bytes[index..]);
        index += vector_as_bytes(&self.masks, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len2880541075, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3029400267, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 20;
        let (pixels, sz): (Vec<Card32>, usize) = vector_from_bytes(bytes, len2880541075)?;
        index += sz;
        let (masks, sz): (Vec<Card32>, usize) = vector_from_bytes(bytes, len3029400267)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                pixels,
                masks,
            },
            index,
        ))
    }
}
impl Request for AllocColorCellsRequest {
    type Reply = AllocColorCellsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        86
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorPlanesRequest {
    pub contiguous: ::std::os::raw::c_char,
    pub cmap: Colormap,
    pub colors: Card16,
    pub reds: Card16,
    pub greens: Card16,
    pub blues: Card16,
}
impl AsByteSequence for AllocColorPlanesRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Colormap>::size()
            + <::std::os::raw::c_char>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.contiguous.as_bytes(&mut bytes[index..]);
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += self.colors.as_bytes(&mut bytes[index..]);
        index += self.reds.as_bytes(&mut bytes[index..]);
        index += self.greens.as_bytes(&mut bytes[index..]);
        index += self.blues.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (contiguous, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (colors, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (reds, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (greens, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blues, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                contiguous,
                cmap,
                colors,
                reds,
                greens,
                blues,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct AllocColorPlanesReply {
    pub sequence: Card16,
    pub length: Card32,
    pub red_mask: Card32,
    pub green_mask: Card32,
    pub blue_mask: Card32,
    pub pixels: Vec<Card32>,
}
impl AsByteSequence for AllocColorPlanesReply {
    #[inline]
    fn size() -> usize {
        <Card32>::size() * 32
            + 8
            + <Card32>::size()
            + <Card32>::size()
            + <Card32>::size()
            + 2
            + 2
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.pixels.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += self.red_mask.as_bytes(&mut bytes[index..]);
        index += self.green_mask.as_bytes(&mut bytes[index..]);
        index += self.blue_mask.as_bytes(&mut bytes[index..]);
        index += 8;
        index += vector_as_bytes(&self.pixels, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len132354375, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (red_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 8;
        let (pixels, sz): (Vec<Card32>, usize) = vector_from_bytes(bytes, len132354375)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                red_mask,
                green_mask,
                blue_mask,
                pixels,
            },
            index,
        ))
    }
}
impl Request for AllocColorPlanesRequest {
    type Reply = AllocColorPlanesReply;
    #[inline]
    fn opcode(&self) -> Byte {
        87
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeColorsRequest {
    pub cmap: Colormap,
    pub plane_mask: Card32,
}
impl AsByteSequence for FreeColorsRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += self.plane_mask.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (plane_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap, plane_mask }, index))
    }
}
impl Request for FreeColorsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        88
    }
}
#[derive(Default, Debug, Clone)]
pub struct Coloritem {
    pub pixel: Card32,
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
    pub flags: Byte,
}
impl AsByteSequence for Coloritem {
    #[inline]
    fn size() -> usize {
        1 + <Byte>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.pixel.as_bytes(&mut bytes[index..]);
        index += self.red.as_bytes(&mut bytes[index..]);
        index += self.green.as_bytes(&mut bytes[index..]);
        index += self.blue.as_bytes(&mut bytes[index..]);
        index += self.flags.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (flags, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                pixel,
                red,
                green,
                blue,
                flags,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct StoreColorsRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for StoreColorsRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap }, index))
    }
}
impl Request for StoreColorsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        89
    }
}
#[derive(Default, Debug, Clone)]
pub struct StoreNamedColorRequest {
    pub flags: Card8,
    pub cmap: Colormap,
    pub pixel: Card32,
    pub name: String,
}
impl AsByteSequence for StoreNamedColorRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + <Card32>::size() + <Colormap>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.flags.as_bytes(&mut bytes[index..]);
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += self.pixel.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (flags, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (pixel, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len404538007, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len404538007)?;
        index += sz;
        Some((
            Self {
                flags,
                cmap,
                pixel,
                name,
            },
            index,
        ))
    }
}
impl Request for StoreNamedColorRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        90
    }
}
#[derive(Default, Debug, Clone)]
pub struct Rgb {
    pub red: Card16,
    pub green: Card16,
    pub blue: Card16,
}
impl AsByteSequence for Rgb {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size() + <Card16>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.red.as_bytes(&mut bytes[index..]);
        index += self.green.as_bytes(&mut bytes[index..]);
        index += self.blue.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((Self { red, green, blue }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryColorsRequest {
    pub cmap: Colormap,
}
impl AsByteSequence for QueryColorsRequest {
    #[inline]
    fn size() -> usize {
        <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cmap }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryColorsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub colors: Vec<Rgb>,
}
impl AsByteSequence for QueryColorsReply {
    #[inline]
    fn size() -> usize {
        <Rgb>::size() * 32 + 22 + 2 + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.colors.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.colors, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len734802987, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (colors, sz): (Vec<Rgb>, usize) = vector_from_bytes(bytes, len734802987)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                colors,
            },
            index,
        ))
    }
}
impl Request for QueryColorsRequest {
    type Reply = QueryColorsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        91
    }
}
#[derive(Default, Debug, Clone)]
pub struct LookupColorRequest {
    pub cmap: Colormap,
    pub name: String,
}
impl AsByteSequence for LookupColorRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + <Colormap>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cmap.as_bytes(&mut bytes[index..]);
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cmap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len1735420195, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len1735420195)?;
        index += sz;
        Some((Self { cmap, name }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct LookupColorReply {
    pub sequence: Card16,
    pub length: Card32,
    pub exact_red: Card16,
    pub exact_green: Card16,
    pub exact_blue: Card16,
    pub visual_red: Card16,
    pub visual_green: Card16,
    pub visual_blue: Card16,
}
impl AsByteSequence for LookupColorReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.exact_red.as_bytes(&mut bytes[index..]);
        index += self.exact_green.as_bytes(&mut bytes[index..]);
        index += self.exact_blue.as_bytes(&mut bytes[index..]);
        index += self.visual_red.as_bytes(&mut bytes[index..]);
        index += self.visual_green.as_bytes(&mut bytes[index..]);
        index += self.visual_blue.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (exact_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (exact_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (exact_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (visual_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                exact_red,
                exact_green,
                exact_blue,
                visual_red,
                visual_green,
                visual_blue,
            },
            index,
        ))
    }
}
impl Request for LookupColorRequest {
    type Reply = LookupColorReply;
    #[inline]
    fn opcode(&self) -> Byte {
        92
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateCursorRequest {
    pub cid: Cursor,
    pub source: Pixmap,
    pub mask: Pixmap,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
    pub x: Card16,
    pub y: Card16,
}
impl AsByteSequence for CreateCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Pixmap>::size()
            + <Pixmap>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cid.as_bytes(&mut bytes[index..]);
        index += self.source.as_bytes(&mut bytes[index..]);
        index += self.mask.as_bytes(&mut bytes[index..]);
        index += self.fore_red.as_bytes(&mut bytes[index..]);
        index += self.fore_green.as_bytes(&mut bytes[index..]);
        index += self.fore_blue.as_bytes(&mut bytes[index..]);
        index += self.back_red.as_bytes(&mut bytes[index..]);
        index += self.back_green.as_bytes(&mut bytes[index..]);
        index += self.back_blue.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cid, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (source, sz): (Pixmap, usize) = <Pixmap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mask, sz): (Pixmap, usize) = <Pixmap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                cid,
                source,
                mask,
                fore_red,
                fore_green,
                fore_blue,
                back_red,
                back_green,
                back_blue,
                x,
                y,
            },
            index,
        ))
    }
}
impl Request for CreateCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        93
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateGlyphCursorRequest {
    pub cid: Cursor,
    pub source_font: Font,
    pub mask_font: Font,
    pub source_char: Card16,
    pub mask_char: Card16,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
}
impl AsByteSequence for CreateGlyphCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Font>::size()
            + <Font>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cid.as_bytes(&mut bytes[index..]);
        index += self.source_font.as_bytes(&mut bytes[index..]);
        index += self.mask_font.as_bytes(&mut bytes[index..]);
        index += self.source_char.as_bytes(&mut bytes[index..]);
        index += self.mask_char.as_bytes(&mut bytes[index..]);
        index += self.fore_red.as_bytes(&mut bytes[index..]);
        index += self.fore_green.as_bytes(&mut bytes[index..]);
        index += self.fore_blue.as_bytes(&mut bytes[index..]);
        index += self.back_red.as_bytes(&mut bytes[index..]);
        index += self.back_green.as_bytes(&mut bytes[index..]);
        index += self.back_blue.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cid, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (source_font, sz): (Font, usize) = <Font>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mask_font, sz): (Font, usize) = <Font>::from_bytes(&bytes[index..])?;
        index += sz;
        let (source_char, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mask_char, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                cid,
                source_font,
                mask_font,
                source_char,
                mask_char,
                fore_red,
                fore_green,
                fore_blue,
                back_red,
                back_green,
                back_blue,
            },
            index,
        ))
    }
}
impl Request for CreateGlyphCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        94
    }
}
#[derive(Default, Debug, Clone)]
pub struct FreeCursorRequest {
    pub cursor: Cursor,
}
impl AsByteSequence for FreeCursorRequest {
    #[inline]
    fn size() -> usize {
        <Cursor>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cursor.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cursor, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { cursor }, index))
    }
}
impl Request for FreeCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        95
    }
}
#[derive(Default, Debug, Clone)]
pub struct RecolorCursorRequest {
    pub cursor: Cursor,
    pub fore_red: Card16,
    pub fore_green: Card16,
    pub fore_blue: Card16,
    pub back_red: Card16,
    pub back_green: Card16,
    pub back_blue: Card16,
}
impl AsByteSequence for RecolorCursorRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Cursor>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.cursor.as_bytes(&mut bytes[index..]);
        index += self.fore_red.as_bytes(&mut bytes[index..]);
        index += self.fore_green.as_bytes(&mut bytes[index..]);
        index += self.fore_blue.as_bytes(&mut bytes[index..]);
        index += self.back_red.as_bytes(&mut bytes[index..]);
        index += self.back_green.as_bytes(&mut bytes[index..]);
        index += self.back_blue.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (cursor, sz): (Cursor, usize) = <Cursor>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (fore_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_red, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_green, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (back_blue, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                cursor,
                fore_red,
                fore_green,
                fore_blue,
                back_red,
                back_green,
                back_blue,
            },
            index,
        ))
    }
}
impl Request for RecolorCursorRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        96
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryBestSizeRequest {
    pub class: Card8,
    pub drawable: Drawable,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for QueryBestSizeRequest {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Drawable>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.class.as_bytes(&mut bytes[index..]);
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (class, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                class,
                drawable,
                width,
                height,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryBestSizeReply {
    pub sequence: Card16,
    pub length: Card32,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for QueryBestSizeReply {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + 1 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                width,
                height,
            },
            index,
        ))
    }
}
impl Request for QueryBestSizeRequest {
    type Reply = QueryBestSizeReply;
    #[inline]
    fn opcode(&self) -> Byte {
        97
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryExtensionRequest {
    pub name: String,
}
impl AsByteSequence for QueryExtensionRequest {
    #[inline]
    fn size() -> usize {
        <u8>::size() * 32 + 2 + 2 + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += (self.name.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 2;
        index += string_as_bytes(&self.name, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (len2970173112, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (name, sz): (String, usize) = string_from_bytes(bytes, len2970173112)?;
        index += sz;
        Some((Self { name }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct QueryExtensionReply {
    pub sequence: Card16,
    pub length: Card32,
    pub present: ::std::os::raw::c_char,
    pub major_opcode: Card8,
    pub first_event: Card8,
    pub first_error: Card8,
}
impl AsByteSequence for QueryExtensionReply {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <::std::os::raw::c_char>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.present.as_bytes(&mut bytes[index..]);
        index += self.major_opcode.as_bytes(&mut bytes[index..]);
        index += self.first_event.as_bytes(&mut bytes[index..]);
        index += self.first_error.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (present, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (major_opcode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (first_event, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (first_error, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                present,
                major_opcode,
                first_event,
                first_error,
            },
            index,
        ))
    }
}
impl Request for QueryExtensionRequest {
    type Reply = QueryExtensionReply;
    #[inline]
    fn opcode(&self) -> Byte {
        98
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListExtensionsRequest;
impl AsByteSequence for ListExtensionsRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListExtensionsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub names: Vec<String>,
}
impl AsByteSequence for ListExtensionsReply {
    #[inline]
    fn size() -> usize {
        <String>::size() * 32 + 24 + 2 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += (self.names.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 24;
        index += vector_as_bytes(&self.names, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3621709584, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 24;
        let (names, sz): (Vec<String>, usize) = vector_from_bytes(bytes, len3621709584)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                names,
            },
            index,
        ))
    }
}
impl Request for ListExtensionsRequest {
    type Reply = ListExtensionsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        99
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeKeyboardMappingRequest {
    pub keycode_count: Card8,
    pub first_keycode: Keycode,
    pub keysyms_per_keycode: Card8,
    pub keysyms: Vec<Keysym>,
}
impl AsByteSequence for ChangeKeyboardMappingRequest {
    #[inline]
    fn size() -> usize {
        <Keysym>::size() * 32 + 2 + <Card8>::size() + <Keycode>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.keycode_count.as_bytes(&mut bytes[index..]);
        index += self.first_keycode.as_bytes(&mut bytes[index..]);
        index += self.keysyms_per_keycode.as_bytes(&mut bytes[index..]);
        index += 2;
        index += vector_as_bytes(&self.keysyms, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (keycode_count, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (first_keycode, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keysyms_per_keycode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (keysyms, sz): (Vec<Keysym>, usize) = vector_from_bytes(
            bytes,
            (keycode_count as u16 * keysyms_per_keycode as u16) as Card16,
        )?;
        index += sz;
        Some((
            Self {
                keycode_count,
                first_keycode,
                keysyms_per_keycode,
                keysyms,
            },
            index,
        ))
    }
}
impl Request for ChangeKeyboardMappingRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        100
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardMappingRequest {
    pub first_keycode: Keycode,
    pub count: Card8,
}
impl AsByteSequence for GetKeyboardMappingRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Keycode>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.first_keycode.as_bytes(&mut bytes[index..]);
        index += self.count.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (first_keycode, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (count, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                first_keycode,
                count,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardMappingReply {
    pub sequence: Card16,
    pub keysyms_per_keycode: Byte,
    pub keysyms: Vec<Keysym>,
}
impl AsByteSequence for GetKeyboardMappingReply {
    #[inline]
    fn size() -> usize {
        <Keysym>::size() * 32 + 24 + <Byte>::size() + 2 + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += (self.keysyms.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.keysyms_per_keycode.as_bytes(&mut bytes[index..]);
        index += 24;
        index += vector_as_bytes(&self.keysyms, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len4035852911, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keysyms_per_keycode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 24;
        let (keysyms, sz): (Vec<Keysym>, usize) = vector_from_bytes(bytes, len4035852911)?;
        index += sz;
        Some((
            Self {
                sequence,
                keysyms_per_keycode,
                keysyms,
            },
            index,
        ))
    }
}
impl Request for GetKeyboardMappingRequest {
    type Reply = GetKeyboardMappingReply;
    #[inline]
    fn opcode(&self) -> Byte {
        101
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeKeyboardControlRequest {}
impl AsByteSequence for ChangeKeyboardControlRequest {
    #[inline]
    fn size() -> usize {
        1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        Some((Self {}, index))
    }
}
impl Request for ChangeKeyboardControlRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        102
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardControlRequest;
impl AsByteSequence for GetKeyboardControlRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetKeyboardControlReply {
    pub sequence: Card16,
    pub length: Card32,
    pub global_auto_repeat: Byte,
    pub led_mask: Card32,
    pub key_click_percent: Card8,
    pub bell_percent: Card8,
    pub bell_pitch: Card16,
    pub bell_duration: Card16,
    pub auto_repeats: [Card8; 32],
}
impl AsByteSequence for GetKeyboardControlReply {
    #[inline]
    fn size() -> usize {
        <[Card8; 32]>::size()
            + 2
            + <Card16>::size()
            + <Card16>::size()
            + <Card8>::size()
            + <Card8>::size()
            + <Card32>::size()
            + <Byte>::size()
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.global_auto_repeat.as_bytes(&mut bytes[index..]);
        index += self.led_mask.as_bytes(&mut bytes[index..]);
        index += self.key_click_percent.as_bytes(&mut bytes[index..]);
        index += self.bell_percent.as_bytes(&mut bytes[index..]);
        index += self.bell_pitch.as_bytes(&mut bytes[index..]);
        index += self.bell_duration.as_bytes(&mut bytes[index..]);
        index += 2;
        index += self.auto_repeats.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (global_auto_repeat, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (led_mask, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (key_click_percent, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bell_percent, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bell_pitch, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (bell_duration, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        let (auto_repeats, sz): ([Card8; 32], usize) = <[Card8; 32]>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                global_auto_repeat,
                led_mask,
                key_click_percent,
                bell_percent,
                bell_pitch,
                bell_duration,
                auto_repeats,
            },
            index,
        ))
    }
}
impl Request for GetKeyboardControlRequest {
    type Reply = GetKeyboardControlReply;
    #[inline]
    fn opcode(&self) -> Byte {
        103
    }
}
#[derive(Default, Debug, Clone)]
pub struct BellRequest {
    pub percent: Int8,
}
impl AsByteSequence for BellRequest {
    #[inline]
    fn size() -> usize {
        <Int8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.percent.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (percent, sz): (Int8, usize) = <Int8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { percent }, index))
    }
}
impl Request for BellRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        104
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangePointerControlRequest {
    pub acceleration_numerator: Int16,
    pub acceleration_denominator: Int16,
    pub threshold: Int16,
    pub do_acceleration: ::std::os::raw::c_char,
    pub do_threshold: ::std::os::raw::c_char,
}
impl AsByteSequence for ChangePointerControlRequest {
    #[inline]
    fn size() -> usize {
        <::std::os::raw::c_char>::size()
            + <::std::os::raw::c_char>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.acceleration_numerator.as_bytes(&mut bytes[index..]);
        index += self.acceleration_denominator.as_bytes(&mut bytes[index..]);
        index += self.threshold.as_bytes(&mut bytes[index..]);
        index += self.do_acceleration.as_bytes(&mut bytes[index..]);
        index += self.do_threshold.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (acceleration_numerator, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (acceleration_denominator, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (threshold, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (do_acceleration, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (do_threshold, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                acceleration_numerator,
                acceleration_denominator,
                threshold,
                do_acceleration,
                do_threshold,
            },
            index,
        ))
    }
}
impl Request for ChangePointerControlRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        105
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerControlRequest;
impl AsByteSequence for GetPointerControlRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerControlReply {
    pub sequence: Card16,
    pub length: Card32,
    pub acceleration_numerator: Card16,
    pub acceleration_denominator: Card16,
    pub threshold: Card16,
}
impl AsByteSequence for GetPointerControlReply {
    #[inline]
    fn size() -> usize {
        18 + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.acceleration_numerator.as_bytes(&mut bytes[index..]);
        index += self.acceleration_denominator.as_bytes(&mut bytes[index..]);
        index += self.threshold.as_bytes(&mut bytes[index..]);
        index += 18;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (acceleration_numerator, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (acceleration_denominator, sz): (Card16, usize) =
            <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (threshold, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 18;
        Some((
            Self {
                sequence,
                length,
                acceleration_numerator,
                acceleration_denominator,
                threshold,
            },
            index,
        ))
    }
}
impl Request for GetPointerControlRequest {
    type Reply = GetPointerControlReply;
    #[inline]
    fn opcode(&self) -> Byte {
        106
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetScreenSaverRequest {
    pub timeout: Int16,
    pub interval: Int16,
    pub prefer_blanking: Card8,
    pub allow_exposures: Card8,
}
impl AsByteSequence for SetScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() + <Card8>::size() + <Int16>::size() + <Int16>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.timeout.as_bytes(&mut bytes[index..]);
        index += self.interval.as_bytes(&mut bytes[index..]);
        index += self.prefer_blanking.as_bytes(&mut bytes[index..]);
        index += self.allow_exposures.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (timeout, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (interval, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (prefer_blanking, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (allow_exposures, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                timeout,
                interval,
                prefer_blanking,
                allow_exposures,
            },
            index,
        ))
    }
}
impl Request for SetScreenSaverRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        107
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetScreenSaverRequest;
impl AsByteSequence for GetScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetScreenSaverReply {
    pub sequence: Card16,
    pub length: Card32,
    pub timeout: Card16,
    pub interval: Card16,
    pub prefer_blanking: Byte,
    pub allow_exposures: Byte,
}
impl AsByteSequence for GetScreenSaverReply {
    #[inline]
    fn size() -> usize {
        18 + <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Card16>::size()
            + 1
            + <Card32>::size()
            + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += 1;
        index += self.timeout.as_bytes(&mut bytes[index..]);
        index += self.interval.as_bytes(&mut bytes[index..]);
        index += self.prefer_blanking.as_bytes(&mut bytes[index..]);
        index += self.allow_exposures.as_bytes(&mut bytes[index..]);
        index += 18;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (timeout, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (interval, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (prefer_blanking, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (allow_exposures, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 18;
        Some((
            Self {
                sequence,
                length,
                timeout,
                interval,
                prefer_blanking,
                allow_exposures,
            },
            index,
        ))
    }
}
impl Request for GetScreenSaverRequest {
    type Reply = GetScreenSaverReply;
    #[inline]
    fn opcode(&self) -> Byte {
        108
    }
}
#[derive(Default, Debug, Clone)]
pub struct ChangeHostsRequest {
    pub mode: Card8,
    pub family: Card8,
    pub address: Vec<Byte>,
}
impl AsByteSequence for ChangeHostsRequest {
    #[inline]
    fn size() -> usize {
        <Byte>::size() * 32 + 2 + 1 + <Card8>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.family.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.address.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.address, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (family, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len3416315701, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (address, sz): (Vec<Byte>, usize) = vector_from_bytes(bytes, len3416315701)?;
        index += sz;
        Some((
            Self {
                mode,
                family,
                address,
            },
            index,
        ))
    }
}
impl Request for ChangeHostsRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        109
    }
}
#[derive(Default, Debug, Clone)]
pub struct Host {
    pub family: Card8,
    pub address: Vec<Byte>,
}
impl AsByteSequence for Host {
    #[inline]
    fn size() -> usize {
        <Byte>::size() * 32 + 2 + 1 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.family.as_bytes(&mut bytes[index..]);
        index += 1;
        index += (self.address.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.address, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (family, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        let (len2467269839, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (address, sz): (Vec<Byte>, usize) = vector_from_bytes(bytes, len2467269839)?;
        index += sz;
        Some((Self { family, address }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListHostsRequest;
impl AsByteSequence for ListHostsRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ListHostsReply {
    pub sequence: Card16,
    pub length: Card32,
    pub mode: Byte,
    pub hosts: Vec<Host>,
}
impl AsByteSequence for ListHostsReply {
    #[inline]
    fn size() -> usize {
        <Host>::size() * 32 + 22 + 2 + <Byte>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += (self.hosts.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 22;
        index += vector_as_bytes(&self.hosts, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len3588867539, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 22;
        let (hosts, sz): (Vec<Host>, usize) = vector_from_bytes(bytes, len3588867539)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                mode,
                hosts,
            },
            index,
        ))
    }
}
impl Request for ListHostsRequest {
    type Reply = ListHostsReply;
    #[inline]
    fn opcode(&self) -> Byte {
        110
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetAccessControlRequest {
    pub mode: Card8,
}
impl AsByteSequence for SetAccessControlRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mode }, index))
    }
}
impl Request for SetAccessControlRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        111
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetCloseDownModeRequest {
    pub mode: Card8,
}
impl AsByteSequence for SetCloseDownModeRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mode }, index))
    }
}
impl Request for SetCloseDownModeRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        112
    }
}
#[derive(Default, Debug, Clone)]
pub struct KillClientRequest {
    pub resource: Card32,
}
impl AsByteSequence for KillClientRequest {
    #[inline]
    fn size() -> usize {
        <Card32>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.resource.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (resource, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { resource }, index))
    }
}
impl Request for KillClientRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        113
    }
}
#[derive(Default, Debug, Clone)]
pub struct RotatePropertiesRequest {
    pub window: Window,
    pub delta: Int16,
    pub atoms: Vec<Atom>,
}
impl AsByteSequence for RotatePropertiesRequest {
    #[inline]
    fn size() -> usize {
        <Atom>::size() * 32 + <Int16>::size() + 2 + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += (self.atoms.len() as Card16).as_bytes(&mut bytes[index..]);
        index += self.delta.as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.atoms, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len318540417, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (delta, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (atoms, sz): (Vec<Atom>, usize) = vector_from_bytes(bytes, len318540417)?;
        index += sz;
        Some((
            Self {
                window,
                delta,
                atoms,
            },
            index,
        ))
    }
}
impl Request for RotatePropertiesRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        114
    }
}
#[derive(Default, Debug, Clone)]
pub struct ForceScreenSaverRequest {
    pub mode: Card8,
}
impl AsByteSequence for ForceScreenSaverRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.mode.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (mode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { mode }, index))
    }
}
impl Request for ForceScreenSaverRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        115
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetPointerMappingRequest {
    pub map: Vec<Card8>,
}
impl AsByteSequence for SetPointerMappingRequest {
    #[inline]
    fn size() -> usize {
        <Card8>::size() * 32 + 2
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += (self.map.len() as Card16).as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.map, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (len363265845, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (map, sz): (Vec<Card8>, usize) = vector_from_bytes(bytes, len363265845)?;
        index += sz;
        Some((Self { map }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetPointerMappingReply {
    pub sequence: Card16,
    pub length: Card32,
    pub status: Byte,
}
impl AsByteSequence for SetPointerMappingReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.status.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (status, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                status,
            },
            index,
        ))
    }
}
impl Request for SetPointerMappingRequest {
    type Reply = SetPointerMappingReply;
    #[inline]
    fn opcode(&self) -> Byte {
        116
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerMappingRequest;
impl AsByteSequence for GetPointerMappingRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetPointerMappingReply {
    pub sequence: Card16,
    pub length: Card32,
    pub map: Vec<Card8>,
}
impl AsByteSequence for GetPointerMappingReply {
    #[inline]
    fn size() -> usize {
        <Card8>::size() * 32 + 24 + 2 + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += (self.map.len() as Card16).as_bytes(&mut bytes[index..]);
        index += 24;
        index += vector_as_bytes(&self.map, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (len2170626870, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 24;
        let (map, sz): (Vec<Card8>, usize) = vector_from_bytes(bytes, len2170626870)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                map,
            },
            index,
        ))
    }
}
impl Request for GetPointerMappingRequest {
    type Reply = GetPointerMappingReply;
    #[inline]
    fn opcode(&self) -> Byte {
        117
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetModifierMappingRequest {
    pub keycodes_per_modifier: Card8,
    pub keycodes: Vec<Keycode>,
}
impl AsByteSequence for SetModifierMappingRequest {
    #[inline]
    fn size() -> usize {
        <Keycode>::size() * 32 + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.keycodes_per_modifier.as_bytes(&mut bytes[index..]);
        index += vector_as_bytes(&self.keycodes, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (keycodes_per_modifier, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keycodes, sz): (Vec<Keycode>, usize) =
            vector_from_bytes(bytes, (keycodes_per_modifier as u16 * 8) as Card16)?;
        index += sz;
        Some((
            Self {
                keycodes_per_modifier,
                keycodes,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SetModifierMappingReply {
    pub sequence: Card16,
    pub length: Card32,
    pub status: Byte,
}
impl AsByteSequence for SetModifierMappingReply {
    #[inline]
    fn size() -> usize {
        <Byte>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.status.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (status, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                status,
            },
            index,
        ))
    }
}
impl Request for SetModifierMappingRequest {
    type Reply = SetModifierMappingReply;
    #[inline]
    fn opcode(&self) -> Byte {
        118
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetModifierMappingRequest;
impl AsByteSequence for GetModifierMappingRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GetModifierMappingReply {
    pub sequence: Card16,
    pub length: Card32,
    pub keycodes_per_modifier: Card8,
    pub keycodes: Vec<Keycode>,
}
impl AsByteSequence for GetModifierMappingReply {
    #[inline]
    fn size() -> usize {
        <Keycode>::size() * 32 + 24 + <Card8>::size() + <Card32>::size() + <Card16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.sequence.as_bytes(&mut bytes[index..]);
        index += self.length.as_bytes(&mut bytes[index..]);
        index += self.keycodes_per_modifier.as_bytes(&mut bytes[index..]);
        index += 24;
        index += vector_as_bytes(&self.keycodes, &mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (sequence, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (length, sz): (Card32, usize) = <Card32>::from_bytes(&bytes[index..])?;
        index += sz;
        let (keycodes_per_modifier, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 24;
        let (keycodes, sz): (Vec<Keycode>, usize) =
            vector_from_bytes(bytes, (keycodes_per_modifier as u16 * 8) as Card16)?;
        index += sz;
        Some((
            Self {
                sequence,
                length,
                keycodes_per_modifier,
                keycodes,
            },
            index,
        ))
    }
}
impl Request for GetModifierMappingRequest {
    type Reply = GetModifierMappingReply;
    #[inline]
    fn opcode(&self) -> Byte {
        119
    }
}
#[derive(Default, Debug, Clone)]
pub struct NoOperationRequest;
impl AsByteSequence for NoOperationRequest {
    #[inline]
    fn size() -> usize {
        0
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        0
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        Some((Self, 0))
    }
}
impl Request for NoOperationRequest {
    type Reply = ();
    #[inline]
    fn opcode(&self) -> Byte {
        127
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum VisualClass {
    StaticGray = 0,
    StaticColor = 2,
    TrueColor = 4,
    DirectColor = 5,
    PseudoColor = 3,
    GrayScale = 1,
}
impl AsByteSequence for VisualClass {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::StaticGray,
                2 => Self::StaticColor,
                4 => Self::TrueColor,
                5 => Self::DirectColor,
                3 => Self::PseudoColor,
                1 => Self::GrayScale,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for VisualClass {
    #[inline]
    fn default() -> Self {
        Self::StaticGray
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct EventMask {
    pub key_press: bool,
    pub key_release: bool,
    pub button_press: bool,
    pub button_release: bool,
    pub enter_window: bool,
    pub leave_window: bool,
    pub pointer_motion: bool,
    pub pointer_motion_hint: bool,
    pub button_one_motion: bool,
    pub button_two_motion: bool,
    pub button_three_motion: bool,
    pub button_four_motion: bool,
    pub button_five_motion: bool,
    pub button_motion: bool,
    pub keymap_state: bool,
    pub exposure: bool,
    pub visibility_change: bool,
    pub structure_notify: bool,
    pub resize_redirect: bool,
    pub substructure_notify: bool,
    pub substructure_redirect: bool,
    pub focus_change: bool,
    pub property_change: bool,
    pub color_map_change: bool,
    pub owner_grab_button: bool,
}
impl AsByteSequence for EventMask {
    #[inline]
    fn size() -> usize {
        <Card32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: Card32 = 0;
        asb |= if self.key_press { 1 << 0 } else { 0 };
        asb |= if self.key_release { 1 << 1 } else { 0 };
        asb |= if self.button_press { 1 << 2 } else { 0 };
        asb |= if self.button_release { 1 << 3 } else { 0 };
        asb |= if self.enter_window { 1 << 4 } else { 0 };
        asb |= if self.leave_window { 1 << 5 } else { 0 };
        asb |= if self.pointer_motion { 1 << 6 } else { 0 };
        asb |= if self.pointer_motion_hint { 1 << 7 } else { 0 };
        asb |= if self.button_one_motion { 1 << 8 } else { 0 };
        asb |= if self.button_two_motion { 1 << 9 } else { 0 };
        asb |= if self.button_three_motion { 1 << 10 } else { 0 };
        asb |= if self.button_four_motion { 1 << 11 } else { 0 };
        asb |= if self.button_five_motion { 1 << 12 } else { 0 };
        asb |= if self.button_motion { 1 << 13 } else { 0 };
        asb |= if self.keymap_state { 1 << 14 } else { 0 };
        asb |= if self.exposure { 1 << 15 } else { 0 };
        asb |= if self.visibility_change { 1 << 16 } else { 0 };
        asb |= if self.structure_notify { 1 << 17 } else { 0 };
        asb |= if self.resize_redirect { 1 << 18 } else { 0 };
        asb |= if self.substructure_notify { 1 << 19 } else { 0 };
        asb |= if self.substructure_redirect {
            1 << 20
        } else {
            0
        };
        asb |= if self.focus_change { 1 << 21 } else { 0 };
        asb |= if self.property_change { 1 << 22 } else { 0 };
        asb |= if self.color_map_change { 1 << 23 } else { 0 };
        asb |= if self.owner_grab_button { 1 << 24 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (Card32, usize) = <Card32>::from_bytes(bytes)?;
        let key_press: bool = ul & (1 << 0) != 0;
        let key_release: bool = ul & (1 << 1) != 0;
        let button_press: bool = ul & (1 << 2) != 0;
        let button_release: bool = ul & (1 << 3) != 0;
        let enter_window: bool = ul & (1 << 4) != 0;
        let leave_window: bool = ul & (1 << 5) != 0;
        let pointer_motion: bool = ul & (1 << 6) != 0;
        let pointer_motion_hint: bool = ul & (1 << 7) != 0;
        let button_one_motion: bool = ul & (1 << 8) != 0;
        let button_two_motion: bool = ul & (1 << 9) != 0;
        let button_three_motion: bool = ul & (1 << 10) != 0;
        let button_four_motion: bool = ul & (1 << 11) != 0;
        let button_five_motion: bool = ul & (1 << 12) != 0;
        let button_motion: bool = ul & (1 << 13) != 0;
        let keymap_state: bool = ul & (1 << 14) != 0;
        let exposure: bool = ul & (1 << 15) != 0;
        let visibility_change: bool = ul & (1 << 16) != 0;
        let structure_notify: bool = ul & (1 << 17) != 0;
        let resize_redirect: bool = ul & (1 << 18) != 0;
        let substructure_notify: bool = ul & (1 << 19) != 0;
        let substructure_redirect: bool = ul & (1 << 20) != 0;
        let focus_change: bool = ul & (1 << 21) != 0;
        let property_change: bool = ul & (1 << 22) != 0;
        let color_map_change: bool = ul & (1 << 23) != 0;
        let owner_grab_button: bool = ul & (1 << 24) != 0;
        Some((
            Self {
                key_press,
                key_release,
                button_press,
                button_release,
                enter_window,
                leave_window,
                pointer_motion,
                pointer_motion_hint,
                button_one_motion,
                button_two_motion,
                button_three_motion,
                button_four_motion,
                button_five_motion,
                button_motion,
                keymap_state,
                exposure,
                visibility_change,
                structure_notify,
                resize_redirect,
                substructure_notify,
                substructure_redirect,
                focus_change,
                property_change,
                color_map_change,
                owner_grab_button,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum BackingStore {
    WhenMapped = 1,
    Always = 2,
    NotUseful = 0,
}
impl AsByteSequence for BackingStore {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::WhenMapped,
                2 => Self::Always,
                0 => Self::NotUseful,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for BackingStore {
    #[inline]
    fn default() -> Self {
        Self::NotUseful
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ImageOrder {
    LsbFirst = 0,
    MsbFirst = 1,
}
impl AsByteSequence for ImageOrder {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::LsbFirst,
                1 => Self::MsbFirst,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ImageOrder {
    #[inline]
    fn default() -> Self {
        Self::LsbFirst
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct KeyButMask {
    pub shift: bool,
    pub lock: bool,
    pub control: bool,
    pub mod_one: bool,
    pub mod_two: bool,
    pub mod_three: bool,
    pub mod_four: bool,
    pub mod_five: bool,
    pub button_one: bool,
    pub button_two: bool,
    pub button_three: bool,
    pub button_four: bool,
    pub button_five: bool,
}
impl AsByteSequence for KeyButMask {
    #[inline]
    fn size() -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u16 = 0;
        asb |= if self.shift { 1 << 0 } else { 0 };
        asb |= if self.lock { 1 << 1 } else { 0 };
        asb |= if self.control { 1 << 2 } else { 0 };
        asb |= if self.mod_one { 1 << 3 } else { 0 };
        asb |= if self.mod_two { 1 << 4 } else { 0 };
        asb |= if self.mod_three { 1 << 5 } else { 0 };
        asb |= if self.mod_four { 1 << 6 } else { 0 };
        asb |= if self.mod_five { 1 << 7 } else { 0 };
        asb |= if self.button_one { 1 << 8 } else { 0 };
        asb |= if self.button_two { 1 << 9 } else { 0 };
        asb |= if self.button_three { 1 << 10 } else { 0 };
        asb |= if self.button_four { 1 << 11 } else { 0 };
        asb |= if self.button_five { 1 << 12 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u16, usize) = <u16>::from_bytes(bytes)?;
        let shift: bool = ul & (1 << 0) != 0;
        let lock: bool = ul & (1 << 1) != 0;
        let control: bool = ul & (1 << 2) != 0;
        let mod_one: bool = ul & (1 << 3) != 0;
        let mod_two: bool = ul & (1 << 4) != 0;
        let mod_three: bool = ul & (1 << 5) != 0;
        let mod_four: bool = ul & (1 << 6) != 0;
        let mod_five: bool = ul & (1 << 7) != 0;
        let button_one: bool = ul & (1 << 8) != 0;
        let button_two: bool = ul & (1 << 9) != 0;
        let button_three: bool = ul & (1 << 10) != 0;
        let button_four: bool = ul & (1 << 11) != 0;
        let button_five: bool = ul & (1 << 12) != 0;
        Some((
            Self {
                shift,
                lock,
                control,
                mod_one,
                mod_two,
                mod_three,
                mod_four,
                mod_five,
                button_one,
                button_two,
                button_three,
                button_four,
                button_five,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Motion {
    Hint = 1,
    Normal = 0,
}
impl AsByteSequence for Motion {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Hint,
                0 => Self::Normal,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Motion {
    #[inline]
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NotifyDetail {
    Inferior = 2,
    NonlinearVirtual = 4,
    Virtual = 1,
    PointerRoot = 6,
    Ancestor = 0,
    None = 7,
    Pointer = 5,
    Nonlinear = 3,
}
impl AsByteSequence for NotifyDetail {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Inferior,
                4 => Self::NonlinearVirtual,
                1 => Self::Virtual,
                6 => Self::PointerRoot,
                0 => Self::Ancestor,
                7 => Self::None,
                5 => Self::Pointer,
                3 => Self::Nonlinear,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for NotifyDetail {
    #[inline]
    fn default() -> Self {
        Self::Ancestor
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum NotifyMode {
    Ungrab = 2,
    Normal = 0,
    Grab = 1,
    WhileGrabbed = 3,
}
impl AsByteSequence for NotifyMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Ungrab,
                0 => Self::Normal,
                1 => Self::Grab,
                3 => Self::WhileGrabbed,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for NotifyMode {
    #[inline]
    fn default() -> Self {
        Self::Normal
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Visibility {
    Unobscured = 0,
    FullyObscured = 2,
    PartiallyObscured = 1,
}
impl AsByteSequence for Visibility {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Unobscured,
                2 => Self::FullyObscured,
                1 => Self::PartiallyObscured,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Visibility {
    #[inline]
    fn default() -> Self {
        Self::Unobscured
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum StackMode {
    Opposite = 4,
    Below = 1,
    TopIf = 2,
    BottomIf = 3,
    Above = 0,
}
impl AsByteSequence for StackMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                4 => Self::Opposite,
                1 => Self::Below,
                2 => Self::TopIf,
                3 => Self::BottomIf,
                0 => Self::Above,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for StackMode {
    #[inline]
    fn default() -> Self {
        Self::Above
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ConfigWindow {
    pub x: bool,
    pub y: bool,
    pub width: bool,
    pub height: bool,
    pub border_width: bool,
    pub sibling: bool,
    pub stack_mode: bool,
}
impl AsByteSequence for ConfigWindow {
    #[inline]
    fn size() -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u16 = 0;
        asb |= if self.x { 1 << 0 } else { 0 };
        asb |= if self.y { 1 << 1 } else { 0 };
        asb |= if self.width { 1 << 2 } else { 0 };
        asb |= if self.height { 1 << 3 } else { 0 };
        asb |= if self.border_width { 1 << 4 } else { 0 };
        asb |= if self.sibling { 1 << 5 } else { 0 };
        asb |= if self.stack_mode { 1 << 6 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u16, usize) = <u16>::from_bytes(bytes)?;
        let x: bool = ul & (1 << 0) != 0;
        let y: bool = ul & (1 << 1) != 0;
        let width: bool = ul & (1 << 2) != 0;
        let height: bool = ul & (1 << 3) != 0;
        let border_width: bool = ul & (1 << 4) != 0;
        let sibling: bool = ul & (1 << 5) != 0;
        let stack_mode: bool = ul & (1 << 6) != 0;
        Some((
            Self {
                x,
                y,
                width,
                height,
                border_width,
                sibling,
                stack_mode,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Place {
    OnTop = 0,
    OnBottom = 1,
}
impl AsByteSequence for Place {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::OnTop,
                1 => Self::OnBottom,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Place {
    #[inline]
    fn default() -> Self {
        Self::OnTop
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Property {
    NewValue = 0,
    Delete = 1,
}
impl AsByteSequence for Property {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::NewValue,
                1 => Self::Delete,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Property {
    #[inline]
    fn default() -> Self {
        Self::NewValue
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ColormapState {
    Installed = 1,
    Uninstalled = 0,
}
impl AsByteSequence for ColormapState {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Installed,
                0 => Self::Uninstalled,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ColormapState {
    #[inline]
    fn default() -> Self {
        Self::Uninstalled
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Mapping {
    Modifier = 0,
    Pointer = 2,
    Keyboard = 1,
}
impl AsByteSequence for Mapping {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Modifier,
                2 => Self::Pointer,
                1 => Self::Keyboard,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Mapping {
    #[inline]
    fn default() -> Self {
        Self::Modifier
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u16)]
pub enum WindowClass {
    InputOnly = 2,
    InputOutput = 1,
    CopyFromParent = 0,
}
impl AsByteSequence for WindowClass {
    #[inline]
    fn size() -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u16).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u16>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::InputOnly,
                1 => Self::InputOutput,
                0 => Self::CopyFromParent,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for WindowClass {
    #[inline]
    fn default() -> Self {
        Self::CopyFromParent
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Gravity {
    North = 2,
    Static = 10,
    East = 6,
    NorthWest = 1,
    South = 8,
    BitForget = 0,
    West = 4,
    NorthEast = 3,
    SouthEast = 9,
    Center = 5,
    SouthWest = 7,
}
impl AsByteSequence for Gravity {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::North,
                10 => Self::Static,
                6 => Self::East,
                1 => Self::NorthWest,
                8 => Self::South,
                0 => Self::BitForget,
                4 => Self::West,
                3 => Self::NorthEast,
                9 => Self::SouthEast,
                5 => Self::Center,
                7 => Self::SouthWest,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Gravity {
    #[inline]
    fn default() -> Self {
        Self::BitForget
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum MapState {
    Viewable = 2,
    Unviewable = 1,
    Unmapped = 0,
}
impl AsByteSequence for MapState {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Viewable,
                1 => Self::Unviewable,
                0 => Self::Unmapped,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for MapState {
    #[inline]
    fn default() -> Self {
        Self::Unmapped
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum SetMode {
    Insert = 0,
    Delete = 1,
}
impl AsByteSequence for SetMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Insert,
                1 => Self::Delete,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for SetMode {
    #[inline]
    fn default() -> Self {
        Self::Insert
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Circulate {
    RaiseLowest = 0,
    LowerHighest = 1,
}
impl AsByteSequence for Circulate {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::RaiseLowest,
                1 => Self::LowerHighest,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Circulate {
    #[inline]
    fn default() -> Self {
        Self::RaiseLowest
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum PropMode {
    Append = 2,
    Prepend = 1,
    Replace = 0,
}
impl AsByteSequence for PropMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Append,
                1 => Self::Prepend,
                0 => Self::Replace,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for PropMode {
    #[inline]
    fn default() -> Self {
        Self::Replace
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum GrabMode {
    Sync = 0,
    Async = 1,
}
impl AsByteSequence for GrabMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Sync,
                1 => Self::Async,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for GrabMode {
    #[inline]
    fn default() -> Self {
        Self::Sync
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum GrabStatus {
    AlreadyGrabbed = 1,
    NotViewable = 3,
    Success = 0,
    InvalidTime = 2,
    Frozen = 4,
}
impl AsByteSequence for GrabStatus {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::AlreadyGrabbed,
                3 => Self::NotViewable,
                0 => Self::Success,
                2 => Self::InvalidTime,
                4 => Self::Frozen,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for GrabStatus {
    #[inline]
    fn default() -> Self {
        Self::Success
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ButtonIndex {
    Four = 4,
    Three = 3,
    Five = 5,
    Two = 2,
    Any = 0,
    One = 1,
}
impl AsByteSequence for ButtonIndex {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                4 => Self::Four,
                3 => Self::Three,
                5 => Self::Five,
                2 => Self::Two,
                0 => Self::Any,
                1 => Self::One,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ButtonIndex {
    #[inline]
    fn default() -> Self {
        Self::Any
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ModMask {
    pub shift: bool,
    pub lock: bool,
    pub control: bool,
    pub one: bool,
    pub two: bool,
    pub three: bool,
    pub four: bool,
    pub five: bool,
    pub any: bool,
}
impl AsByteSequence for ModMask {
    #[inline]
    fn size() -> usize {
        <u16>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u16 = 0;
        asb |= if self.shift { 1 << 0 } else { 0 };
        asb |= if self.lock { 1 << 1 } else { 0 };
        asb |= if self.control { 1 << 2 } else { 0 };
        asb |= if self.one { 1 << 3 } else { 0 };
        asb |= if self.two { 1 << 4 } else { 0 };
        asb |= if self.three { 1 << 5 } else { 0 };
        asb |= if self.four { 1 << 6 } else { 0 };
        asb |= if self.five { 1 << 7 } else { 0 };
        asb |= if self.any { 1 << 15 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u16, usize) = <u16>::from_bytes(bytes)?;
        let shift: bool = ul & (1 << 0) != 0;
        let lock: bool = ul & (1 << 1) != 0;
        let control: bool = ul & (1 << 2) != 0;
        let one: bool = ul & (1 << 3) != 0;
        let two: bool = ul & (1 << 4) != 0;
        let three: bool = ul & (1 << 5) != 0;
        let four: bool = ul & (1 << 6) != 0;
        let five: bool = ul & (1 << 7) != 0;
        let any: bool = ul & (1 << 15) != 0;
        Some((
            Self {
                shift,
                lock,
                control,
                one,
                two,
                three,
                four,
                five,
                any,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Allow {
    AsyncPointer = 0,
    AsyncBoth = 6,
    SyncPointer = 1,
    AsyncKeyboard = 3,
    SyncKeyboard = 4,
    SyncBoth = 7,
    ReplayKeyboard = 5,
    ReplayPointer = 2,
}
impl AsByteSequence for Allow {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::AsyncPointer,
                6 => Self::AsyncBoth,
                1 => Self::SyncPointer,
                3 => Self::AsyncKeyboard,
                4 => Self::SyncKeyboard,
                7 => Self::SyncBoth,
                5 => Self::ReplayKeyboard,
                2 => Self::ReplayPointer,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Allow {
    #[inline]
    fn default() -> Self {
        Self::AsyncPointer
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum InputFocus {
    PointerRoot = 1,
    Parent = 2,
    None = 0,
    FollowKeyboard = 3,
}
impl AsByteSequence for InputFocus {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::PointerRoot,
                2 => Self::Parent,
                0 => Self::None,
                3 => Self::FollowKeyboard,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for InputFocus {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum FontDraw {
    RightToLeft = 1,
    LeftToRight = 0,
}
impl AsByteSequence for FontDraw {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::RightToLeft,
                0 => Self::LeftToRight,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for FontDraw {
    #[inline]
    fn default() -> Self {
        Self::LeftToRight
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ClipOrdering {
    YxSorted = 2,
    YSorted = 1,
    YxBanded = 3,
    Unsorted = 0,
}
impl AsByteSequence for ClipOrdering {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::YxSorted,
                1 => Self::YSorted,
                3 => Self::YxBanded,
                0 => Self::Unsorted,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ClipOrdering {
    #[inline]
    fn default() -> Self {
        Self::Unsorted
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum CoordMode {
    Previous = 1,
    Origin = 0,
}
impl AsByteSequence for CoordMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Previous,
                0 => Self::Origin,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for CoordMode {
    #[inline]
    fn default() -> Self {
        Self::Origin
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum PolyShape {
    Convex = 2,
    Complex = 0,
    Nonconvex = 1,
}
impl AsByteSequence for PolyShape {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Convex,
                0 => Self::Complex,
                1 => Self::Nonconvex,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for PolyShape {
    #[inline]
    fn default() -> Self {
        Self::Complex
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ImageFormat {
    XyPixmap = 1,
    XyBitmap = 0,
    ZPixmap = 2,
}
impl AsByteSequence for ImageFormat {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::XyPixmap,
                0 => Self::XyBitmap,
                2 => Self::ZPixmap,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ImageFormat {
    #[inline]
    fn default() -> Self {
        Self::XyBitmap
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ColormapAlloc {
    None = 0,
    All = 1,
}
impl AsByteSequence for ColormapAlloc {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::None,
                1 => Self::All,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ColormapAlloc {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, Default)]
pub struct ColorFlag {
    pub red: bool,
    pub green: bool,
    pub blue: bool,
}
impl AsByteSequence for ColorFlag {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u8 = 0;
        asb |= if self.red { 1 << 0 } else { 0 };
        asb |= if self.green { 1 << 1 } else { 0 };
        asb |= if self.blue { 1 << 2 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u8, usize) = <u8>::from_bytes(bytes)?;
        let red: bool = ul & (1 << 0) != 0;
        let green: bool = ul & (1 << 1) != 0;
        let blue: bool = ul & (1 << 2) != 0;
        Some((Self { red, green, blue }, len))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum QueryShapeOf {
    FastestStipple = 2,
    LargestCursor = 0,
    FastestTile = 1,
}
impl AsByteSequence for QueryShapeOf {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::FastestStipple,
                0 => Self::LargestCursor,
                1 => Self::FastestTile,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for QueryShapeOf {
    #[inline]
    fn default() -> Self {
        Self::LargestCursor
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum AutoRepeatMode {
    Default = 2,
    Off = 0,
    On = 1,
}
impl AsByteSequence for AutoRepeatMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Default,
                0 => Self::Off,
                1 => Self::On,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for AutoRepeatMode {
    #[inline]
    fn default() -> Self {
        Self::Off
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Blanking {
    Default = 2,
    Preferred = 1,
    NotPreferred = 0,
}
impl AsByteSequence for Blanking {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Default,
                1 => Self::Preferred,
                0 => Self::NotPreferred,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Blanking {
    #[inline]
    fn default() -> Self {
        Self::NotPreferred
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Exposures {
    Default = 2,
    Allowed = 1,
    NotAllowed = 0,
}
impl AsByteSequence for Exposures {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Default,
                1 => Self::Allowed,
                0 => Self::NotAllowed,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Exposures {
    #[inline]
    fn default() -> Self {
        Self::NotAllowed
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum HostMode {
    Delete = 1,
    Insert = 0,
}
impl AsByteSequence for HostMode {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Delete,
                0 => Self::Insert,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for HostMode {
    #[inline]
    fn default() -> Self {
        Self::Insert
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum Family {
    Chaos = 2,
    InternetSix = 6,
    Internet = 0,
    ServerInterpreted = 5,
    DeCnet = 1,
}
impl AsByteSequence for Family {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Chaos,
                6 => Self::InternetSix,
                0 => Self::Internet,
                5 => Self::ServerInterpreted,
                1 => Self::DeCnet,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for Family {
    #[inline]
    fn default() -> Self {
        Self::Internet
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum AccessControl {
    Disable = 0,
    Enable = 1,
}
impl AsByteSequence for AccessControl {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Disable,
                1 => Self::Enable,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for AccessControl {
    #[inline]
    fn default() -> Self {
        Self::Disable
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum CloseDown {
    RetainTemporary = 2,
    DestroyAll = 0,
    RetainPermanent = 1,
}
impl AsByteSequence for CloseDown {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::RetainTemporary,
                0 => Self::DestroyAll,
                1 => Self::RetainPermanent,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for CloseDown {
    #[inline]
    fn default() -> Self {
        Self::DestroyAll
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum ScreenSaver {
    Active = 1,
    Reset = 0,
}
impl AsByteSequence for ScreenSaver {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Active,
                0 => Self::Reset,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ScreenSaver {
    #[inline]
    fn default() -> Self {
        Self::Reset
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u8)]
pub enum MappingStatus {
    Failure = 2,
    Success = 0,
    Busy = 1,
}
impl AsByteSequence for MappingStatus {
    #[inline]
    fn size() -> usize {
        <u8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u8).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u8>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Failure,
                0 => Self::Success,
                1 => Self::Busy,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for MappingStatus {
    #[inline]
    fn default() -> Self {
        Self::Success
    }
}
pub const WINDOW_NONE: Window = Window::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct ButtonMask {
    pub one: bool,
    pub two: bool,
    pub three: bool,
    pub four: bool,
    pub five: bool,
    pub any: bool,
}
impl AsByteSequence for ButtonMask {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u32 = 0;
        asb |= if self.one { 1 << 8 } else { 0 };
        asb |= if self.two { 1 << 9 } else { 0 };
        asb |= if self.three { 1 << 10 } else { 0 };
        asb |= if self.four { 1 << 11 } else { 0 };
        asb |= if self.five { 1 << 12 } else { 0 };
        asb |= if self.any { 1 << 15 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u32, usize) = <u32>::from_bytes(bytes)?;
        let one: bool = ul & (1 << 8) != 0;
        let two: bool = ul & (1 << 9) != 0;
        let three: bool = ul & (1 << 10) != 0;
        let four: bool = ul & (1 << 11) != 0;
        let five: bool = ul & (1 << 12) != 0;
        let any: bool = ul & (1 << 15) != 0;
        Some((
            Self {
                one,
                two,
                three,
                four,
                five,
                any,
            },
            len,
        ))
    }
}
pub const ATOM_NONE: Atom = Atom::const_from_xid(0);
pub const ATOM_ANY: Atom = Atom::const_from_xid(0);
pub const ATOM_PRIMARY: Atom = Atom::const_from_xid(1);
pub const ATOM_SECONDARY: Atom = Atom::const_from_xid(2);
pub const ATOM_ARC: Atom = Atom::const_from_xid(3);
pub const ATOM_ATOM: Atom = Atom::const_from_xid(4);
pub const ATOM_BITMAP: Atom = Atom::const_from_xid(5);
pub const ATOM_CARDINAL: Atom = Atom::const_from_xid(6);
pub const ATOM_COLORMAP: Atom = Atom::const_from_xid(7);
pub const ATOM_CURSOR: Atom = Atom::const_from_xid(8);
pub const ATOM_CUT_BUFFER_ZERO: Atom = Atom::const_from_xid(9);
pub const ATOM_CUT_BUFFER_ONE: Atom = Atom::const_from_xid(10);
pub const ATOM_CUT_BUFFER_TWO: Atom = Atom::const_from_xid(11);
pub const ATOM_CUT_BUFFER_THREE: Atom = Atom::const_from_xid(12);
pub const ATOM_CUT_BUFFER_FOUR: Atom = Atom::const_from_xid(13);
pub const ATOM_CUT_BUFFER_FIVE: Atom = Atom::const_from_xid(14);
pub const ATOM_CUT_BUFFER_SIX: Atom = Atom::const_from_xid(15);
pub const ATOM_CUT_BUFFER_SEVEN: Atom = Atom::const_from_xid(16);
pub const ATOM_DRAWABLE: Atom = Atom::const_from_xid(17);
pub const ATOM_FONT: Atom = Atom::const_from_xid(18);
pub const ATOM_INTEGER: Atom = Atom::const_from_xid(19);
pub const ATOM_PIXMAP: Atom = Atom::const_from_xid(20);
pub const ATOM_POINT: Atom = Atom::const_from_xid(21);
pub const ATOM_RECTANGLE: Atom = Atom::const_from_xid(22);
pub const ATOM_RESOURCE_MANAGER: Atom = Atom::const_from_xid(23);
pub const ATOM_RGB_COLOR_MAP: Atom = Atom::const_from_xid(24);
pub const ATOM_RGB_BEST_MAP: Atom = Atom::const_from_xid(25);
pub const ATOM_RGB_BLUE_MAP: Atom = Atom::const_from_xid(26);
pub const ATOM_RGB_DEFAULT_MAP: Atom = Atom::const_from_xid(27);
pub const ATOM_RGB_GRAY_MAP: Atom = Atom::const_from_xid(28);
pub const ATOM_RGB_GREEN_MAP: Atom = Atom::const_from_xid(29);
pub const ATOM_RGB_RED_MAP: Atom = Atom::const_from_xid(30);
pub const ATOM_STRING: Atom = Atom::const_from_xid(31);
pub const ATOM_VISUALID: Atom = Atom::const_from_xid(32);
pub const ATOM_WINDOW: Atom = Atom::const_from_xid(33);
pub const ATOM_WM_COMMAND: Atom = Atom::const_from_xid(34);
pub const ATOM_WM_HINTS: Atom = Atom::const_from_xid(35);
pub const ATOM_WM_CLIENT_MACHINE: Atom = Atom::const_from_xid(36);
pub const ATOM_WM_ICON_NAME: Atom = Atom::const_from_xid(37);
pub const ATOM_WM_ICON_SIZE: Atom = Atom::const_from_xid(38);
pub const ATOM_WM_NAME: Atom = Atom::const_from_xid(39);
pub const ATOM_WM_NORMAL_HINTS: Atom = Atom::const_from_xid(40);
pub const ATOM_WM_SIZE_HINTS: Atom = Atom::const_from_xid(41);
pub const ATOM_WM_ZOOM_HINTS: Atom = Atom::const_from_xid(42);
pub const ATOM_MIN_SPACE: Atom = Atom::const_from_xid(43);
pub const ATOM_NORM_SPACE: Atom = Atom::const_from_xid(44);
pub const ATOM_MAX_SPACE: Atom = Atom::const_from_xid(45);
pub const ATOM_END_SPACE: Atom = Atom::const_from_xid(46);
pub const ATOM_SUPERSCRIPT_X: Atom = Atom::const_from_xid(47);
pub const ATOM_SUPERSCRIPT_Y: Atom = Atom::const_from_xid(48);
pub const ATOM_SUBSCRIPT_X: Atom = Atom::const_from_xid(49);
pub const ATOM_SUBSCRIPT_Y: Atom = Atom::const_from_xid(50);
pub const ATOM_UNDERLINE_POSITION: Atom = Atom::const_from_xid(51);
pub const ATOM_UNDERLINE_THICKNESS: Atom = Atom::const_from_xid(52);
pub const ATOM_STRIKEOUT_ASCENT: Atom = Atom::const_from_xid(53);
pub const ATOM_STRIKEOUT_DESCENT: Atom = Atom::const_from_xid(54);
pub const ATOM_ITALIC_ANGLE: Atom = Atom::const_from_xid(55);
pub const ATOM_X_HEIGHT: Atom = Atom::const_from_xid(56);
pub const ATOM_QUAD_WIDTH: Atom = Atom::const_from_xid(57);
pub const ATOM_WEIGHT: Atom = Atom::const_from_xid(58);
pub const ATOM_POINT_SIZE: Atom = Atom::const_from_xid(59);
pub const ATOM_RESOLUTION: Atom = Atom::const_from_xid(60);
pub const ATOM_COPYRIGHT: Atom = Atom::const_from_xid(61);
pub const ATOM_NOTICE: Atom = Atom::const_from_xid(62);
pub const ATOM_FONT_NAME: Atom = Atom::const_from_xid(63);
pub const ATOM_FAMILY_NAME: Atom = Atom::const_from_xid(64);
pub const ATOM_FULL_NAME: Atom = Atom::const_from_xid(65);
pub const ATOM_CAP_HEIGHT: Atom = Atom::const_from_xid(66);
pub const ATOM_WM_CLASS: Atom = Atom::const_from_xid(67);
pub const ATOM_WM_TRANSIENT_FOR: Atom = Atom::const_from_xid(68);
pub const COLORMAP_NONE: Colormap = Colormap::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct CW {
    pub back_pixmap: bool,
    pub back_pixel: bool,
    pub border_pixmap: bool,
    pub border_pixel: bool,
    pub bit_gravity: bool,
    pub win_gravity: bool,
    pub backing_store: bool,
    pub backing_planes: bool,
    pub backing_pixel: bool,
    pub override_redirect: bool,
    pub save_under: bool,
    pub event_mask: bool,
    pub dont_propagate: bool,
    pub colormap: bool,
    pub cursor: bool,
}
impl AsByteSequence for CW {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u32 = 0;
        asb |= if self.back_pixmap { 1 << 0 } else { 0 };
        asb |= if self.back_pixel { 1 << 1 } else { 0 };
        asb |= if self.border_pixmap { 1 << 2 } else { 0 };
        asb |= if self.border_pixel { 1 << 3 } else { 0 };
        asb |= if self.bit_gravity { 1 << 4 } else { 0 };
        asb |= if self.win_gravity { 1 << 5 } else { 0 };
        asb |= if self.backing_store { 1 << 6 } else { 0 };
        asb |= if self.backing_planes { 1 << 7 } else { 0 };
        asb |= if self.backing_pixel { 1 << 8 } else { 0 };
        asb |= if self.override_redirect { 1 << 9 } else { 0 };
        asb |= if self.save_under { 1 << 10 } else { 0 };
        asb |= if self.event_mask { 1 << 11 } else { 0 };
        asb |= if self.dont_propagate { 1 << 12 } else { 0 };
        asb |= if self.colormap { 1 << 13 } else { 0 };
        asb |= if self.cursor { 1 << 14 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u32, usize) = <u32>::from_bytes(bytes)?;
        let back_pixmap: bool = ul & (1 << 0) != 0;
        let back_pixel: bool = ul & (1 << 1) != 0;
        let border_pixmap: bool = ul & (1 << 2) != 0;
        let border_pixel: bool = ul & (1 << 3) != 0;
        let bit_gravity: bool = ul & (1 << 4) != 0;
        let win_gravity: bool = ul & (1 << 5) != 0;
        let backing_store: bool = ul & (1 << 6) != 0;
        let backing_planes: bool = ul & (1 << 7) != 0;
        let backing_pixel: bool = ul & (1 << 8) != 0;
        let override_redirect: bool = ul & (1 << 9) != 0;
        let save_under: bool = ul & (1 << 10) != 0;
        let event_mask: bool = ul & (1 << 11) != 0;
        let dont_propagate: bool = ul & (1 << 12) != 0;
        let colormap: bool = ul & (1 << 13) != 0;
        let cursor: bool = ul & (1 << 14) != 0;
        Some((
            Self {
                back_pixmap,
                back_pixel,
                border_pixmap,
                border_pixel,
                bit_gravity,
                win_gravity,
                backing_store,
                backing_planes,
                backing_pixel,
                override_redirect,
                save_under,
                event_mask,
                dont_propagate,
                colormap,
                cursor,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum BackPixmap {
    None = 0,
    ParentRelative = 1,
}
impl AsByteSequence for BackPixmap {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::None,
                1 => Self::ParentRelative,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for BackPixmap {
    #[inline]
    fn default() -> Self {
        Self::None
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum SendEventDest {
    ItemFocus = 1,
    PointerWindow = 0,
}
impl AsByteSequence for SendEventDest {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::ItemFocus,
                0 => Self::PointerWindow,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for SendEventDest {
    #[inline]
    fn default() -> Self {
        Self::PointerWindow
    }
}
pub const CURSOR_NONE: Cursor = Cursor::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct GC {
    pub function: bool,
    pub plane_mask: bool,
    pub foreground: bool,
    pub background: bool,
    pub line_width: bool,
    pub line_style: bool,
    pub cap_style: bool,
    pub join_style: bool,
    pub fill_style: bool,
    pub fill_rule: bool,
    pub tile: bool,
    pub stipple: bool,
    pub tile_stipple_origin_x: bool,
    pub tile_stipple_origin_y: bool,
    pub font: bool,
    pub subwindow_mode: bool,
    pub graphics_exposures: bool,
    pub clip_origin_x: bool,
    pub clip_origin_y: bool,
    pub clip_mask: bool,
    pub dash_offset: bool,
    pub dash_list: bool,
    pub arc_mode: bool,
}
impl AsByteSequence for GC {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u32 = 0;
        asb |= if self.function { 1 << 0 } else { 0 };
        asb |= if self.plane_mask { 1 << 1 } else { 0 };
        asb |= if self.foreground { 1 << 2 } else { 0 };
        asb |= if self.background { 1 << 3 } else { 0 };
        asb |= if self.line_width { 1 << 4 } else { 0 };
        asb |= if self.line_style { 1 << 5 } else { 0 };
        asb |= if self.cap_style { 1 << 6 } else { 0 };
        asb |= if self.join_style { 1 << 7 } else { 0 };
        asb |= if self.fill_style { 1 << 8 } else { 0 };
        asb |= if self.fill_rule { 1 << 9 } else { 0 };
        asb |= if self.tile { 1 << 10 } else { 0 };
        asb |= if self.stipple { 1 << 11 } else { 0 };
        asb |= if self.tile_stipple_origin_x {
            1 << 12
        } else {
            0
        };
        asb |= if self.tile_stipple_origin_y {
            1 << 13
        } else {
            0
        };
        asb |= if self.font { 1 << 14 } else { 0 };
        asb |= if self.subwindow_mode { 1 << 15 } else { 0 };
        asb |= if self.graphics_exposures { 1 << 16 } else { 0 };
        asb |= if self.clip_origin_x { 1 << 17 } else { 0 };
        asb |= if self.clip_origin_y { 1 << 18 } else { 0 };
        asb |= if self.clip_mask { 1 << 19 } else { 0 };
        asb |= if self.dash_offset { 1 << 20 } else { 0 };
        asb |= if self.dash_list { 1 << 21 } else { 0 };
        asb |= if self.arc_mode { 1 << 22 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u32, usize) = <u32>::from_bytes(bytes)?;
        let function: bool = ul & (1 << 0) != 0;
        let plane_mask: bool = ul & (1 << 1) != 0;
        let foreground: bool = ul & (1 << 2) != 0;
        let background: bool = ul & (1 << 3) != 0;
        let line_width: bool = ul & (1 << 4) != 0;
        let line_style: bool = ul & (1 << 5) != 0;
        let cap_style: bool = ul & (1 << 6) != 0;
        let join_style: bool = ul & (1 << 7) != 0;
        let fill_style: bool = ul & (1 << 8) != 0;
        let fill_rule: bool = ul & (1 << 9) != 0;
        let tile: bool = ul & (1 << 10) != 0;
        let stipple: bool = ul & (1 << 11) != 0;
        let tile_stipple_origin_x: bool = ul & (1 << 12) != 0;
        let tile_stipple_origin_y: bool = ul & (1 << 13) != 0;
        let font: bool = ul & (1 << 14) != 0;
        let subwindow_mode: bool = ul & (1 << 15) != 0;
        let graphics_exposures: bool = ul & (1 << 16) != 0;
        let clip_origin_x: bool = ul & (1 << 17) != 0;
        let clip_origin_y: bool = ul & (1 << 18) != 0;
        let clip_mask: bool = ul & (1 << 19) != 0;
        let dash_offset: bool = ul & (1 << 20) != 0;
        let dash_list: bool = ul & (1 << 21) != 0;
        let arc_mode: bool = ul & (1 << 22) != 0;
        Some((
            Self {
                function,
                plane_mask,
                foreground,
                background,
                line_width,
                line_style,
                cap_style,
                join_style,
                fill_style,
                fill_rule,
                tile,
                stipple,
                tile_stipple_origin_x,
                tile_stipple_origin_y,
                font,
                subwindow_mode,
                graphics_exposures,
                clip_origin_x,
                clip_origin_y,
                clip_mask,
                dash_offset,
                dash_list,
                arc_mode,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum GX {
    OrInverted = 13,
    Clear = 0,
    AndReverse = 2,
    Nand = 14,
    AndInverted = 4,
    CopyInverted = 12,
    Nor = 8,
    OrReverse = 11,
    Invert = 10,
    Noop = 5,
    And = 1,
    Equiv = 9,
    Set = 15,
    Xor = 6,
    Or = 7,
    Copy = 3,
}
impl AsByteSequence for GX {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                13 => Self::OrInverted,
                0 => Self::Clear,
                2 => Self::AndReverse,
                14 => Self::Nand,
                4 => Self::AndInverted,
                12 => Self::CopyInverted,
                8 => Self::Nor,
                11 => Self::OrReverse,
                10 => Self::Invert,
                5 => Self::Noop,
                1 => Self::And,
                9 => Self::Equiv,
                15 => Self::Set,
                6 => Self::Xor,
                7 => Self::Or,
                3 => Self::Copy,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for GX {
    #[inline]
    fn default() -> Self {
        Self::Clear
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum LineStyle {
    Solid = 0,
    DoubleDash = 2,
    OnOffDash = 1,
}
impl AsByteSequence for LineStyle {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Solid,
                2 => Self::DoubleDash,
                1 => Self::OnOffDash,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for LineStyle {
    #[inline]
    fn default() -> Self {
        Self::Solid
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum CapStyle {
    Projecting = 3,
    Round = 2,
    NotLast = 0,
    Butt = 1,
}
impl AsByteSequence for CapStyle {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                3 => Self::Projecting,
                2 => Self::Round,
                0 => Self::NotLast,
                1 => Self::Butt,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for CapStyle {
    #[inline]
    fn default() -> Self {
        Self::NotLast
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum JoinStyle {
    Bevel = 2,
    Round = 1,
    Miter = 0,
}
impl AsByteSequence for JoinStyle {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                2 => Self::Bevel,
                1 => Self::Round,
                0 => Self::Miter,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for JoinStyle {
    #[inline]
    fn default() -> Self {
        Self::Miter
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum FillStyle {
    Tiled = 1,
    OpaqueStippled = 3,
    Solid = 0,
    Stippled = 2,
}
impl AsByteSequence for FillStyle {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Tiled,
                3 => Self::OpaqueStippled,
                0 => Self::Solid,
                2 => Self::Stippled,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for FillStyle {
    #[inline]
    fn default() -> Self {
        Self::Solid
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum FillRule {
    Winding = 1,
    EvenOdd = 0,
}
impl AsByteSequence for FillRule {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                1 => Self::Winding,
                0 => Self::EvenOdd,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for FillRule {
    #[inline]
    fn default() -> Self {
        Self::EvenOdd
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum SubwindowMode {
    ClipByChildren = 0,
    IncludeInferiors = 1,
}
impl AsByteSequence for SubwindowMode {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::ClipByChildren,
                1 => Self::IncludeInferiors,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for SubwindowMode {
    #[inline]
    fn default() -> Self {
        Self::ClipByChildren
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum ArcMode {
    Chord = 0,
    PieSlice = 1,
}
impl AsByteSequence for ArcMode {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Chord,
                1 => Self::PieSlice,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for ArcMode {
    #[inline]
    fn default() -> Self {
        Self::Chord
    }
}
pub const PIXMAP_NONE: Pixmap = Pixmap::const_from_xid(0);
pub const FONT_NONE: Font = Font::const_from_xid(0);
#[derive(Debug, Copy, Clone, Default)]
pub struct KB {
    pub key_click_percent: bool,
    pub bell_percent: bool,
    pub bell_pitch: bool,
    pub bell_duration: bool,
    pub led: bool,
    pub led_mode: bool,
    pub key: bool,
    pub auto_repeat_mode: bool,
}
impl AsByteSequence for KB {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut asb: u32 = 0;
        asb |= if self.key_click_percent { 1 << 0 } else { 0 };
        asb |= if self.bell_percent { 1 << 1 } else { 0 };
        asb |= if self.bell_pitch { 1 << 2 } else { 0 };
        asb |= if self.bell_duration { 1 << 3 } else { 0 };
        asb |= if self.led { 1 << 4 } else { 0 };
        asb |= if self.led_mode { 1 << 5 } else { 0 };
        asb |= if self.key { 1 << 6 } else { 0 };
        asb |= if self.auto_repeat_mode { 1 << 7 } else { 0 };
        asb.as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len): (u32, usize) = <u32>::from_bytes(bytes)?;
        let key_click_percent: bool = ul & (1 << 0) != 0;
        let bell_percent: bool = ul & (1 << 1) != 0;
        let bell_pitch: bool = ul & (1 << 2) != 0;
        let bell_duration: bool = ul & (1 << 3) != 0;
        let led: bool = ul & (1 << 4) != 0;
        let led_mode: bool = ul & (1 << 5) != 0;
        let key: bool = ul & (1 << 6) != 0;
        let auto_repeat_mode: bool = ul & (1 << 7) != 0;
        Some((
            Self {
                key_click_percent,
                bell_percent,
                bell_pitch,
                bell_duration,
                led,
                led_mode,
                key,
                auto_repeat_mode,
            },
            len,
        ))
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum LedMode {
    Off = 0,
    On = 1,
}
impl AsByteSequence for LedMode {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                0 => Self::Off,
                1 => Self::On,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for LedMode {
    #[inline]
    fn default() -> Self {
        Self::Off
    }
}
#[derive(Debug, Copy, Clone, PartialEq, Eq)]
#[repr(u32)]
pub enum MapIndex {
    Three = 5,
    Shift = 0,
    Two = 4,
    Four = 6,
    Lock = 1,
    Control = 2,
    Five = 7,
    One = 3,
}
impl AsByteSequence for MapIndex {
    #[inline]
    fn size() -> usize {
        <u32>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        (*self as u32).as_bytes(bytes)
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let (ul, len) = <u32>::from_bytes(bytes)?;
        Some((
            match ul {
                5 => Self::Three,
                0 => Self::Shift,
                4 => Self::Two,
                6 => Self::Four,
                1 => Self::Lock,
                2 => Self::Control,
                7 => Self::Five,
                3 => Self::One,
                _ => return None,
            },
            len,
        ))
    }
}
impl Default for MapIndex {
    #[inline]
    fn default() -> Self {
        Self::Shift
    }
}
#[derive(Default, Debug, Clone)]
pub struct ResizeRequestEvent {
    pub window: Window,
    pub width: Card16,
    pub height: Card16,
}
impl AsByteSequence for ResizeRequestEvent {
    #[inline]
    fn size() -> usize {
        <Card16>::size() + <Card16>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                window,
                width,
                height,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GraphicsExposureEvent {
    pub drawable: Drawable,
    pub x: Card16,
    pub y: Card16,
    pub width: Card16,
    pub height: Card16,
    pub minor_opcode: Card16,
    pub count: Card16,
    pub major_opcode: Card8,
}
impl AsByteSequence for GraphicsExposureEvent {
    #[inline]
    fn size() -> usize {
        3 + <Card8>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Drawable>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.minor_opcode.as_bytes(&mut bytes[index..]);
        index += self.count.as_bytes(&mut bytes[index..]);
        index += self.major_opcode.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (minor_opcode, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (count, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (major_opcode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                drawable,
                x,
                y,
                width,
                height,
                minor_opcode,
                count,
                major_opcode,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ExposeEvent {
    pub window: Window,
    pub x: Card16,
    pub y: Card16,
    pub width: Card16,
    pub height: Card16,
    pub count: Card16,
}
impl AsByteSequence for ExposeEvent {
    #[inline]
    fn size() -> usize {
        2 + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.count.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (count, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                window,
                x,
                y,
                width,
                height,
                count,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct FocusInEvent {
    pub detail: Byte,
    pub event: Window,
    pub mode: Byte,
}
impl AsByteSequence for FocusInEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                detail,
                event,
                mode,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct CreateNotifyEvent {
    pub parent: Window,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for CreateNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.border_width.as_bytes(&mut bytes[index..]);
        index += self.override_redirect.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (border_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (override_redirect, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                parent,
                window,
                x,
                y,
                width,
                height,
                border_width,
                override_redirect,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateRequest {
    pub event: Window,
    pub window: Window,
    pub place: Byte,
}
impl AsByteSequence for CirculateRequest {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + 4 + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.place.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (place, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                event,
                window,
                place,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct MotionNotifyEvent {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for MotionNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                same_screen,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub above_sibling: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for ConfigureNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.above_sibling.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.border_width.as_bytes(&mut bytes[index..]);
        index += self.override_redirect.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (above_sibling, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (border_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (override_redirect, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                event,
                window,
                above_sibling,
                x,
                y,
                width,
                height,
                border_width,
                override_redirect,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct GravityNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub x: Int16,
    pub y: Int16,
}
impl AsByteSequence for GravityNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Int16>::size() + <Int16>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                event,
                window,
                x,
                y,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct PropertyNotifyEvent {
    pub window: Window,
    pub atom: Atom,
    pub time: Timestamp,
    pub state: Byte,
}
impl AsByteSequence for PropertyNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Timestamp>::size() + <Atom>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.atom.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (atom, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                window,
                atom,
                time,
                state,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ButtonRelease {
    pub detail: Button,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for ButtonRelease {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Button>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Button, usize) = <Button>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                same_screen,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionRequestEvent {
    pub time: Timestamp,
    pub owner: Window,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
}
impl AsByteSequence for SelectionRequestEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.owner.as_bytes(&mut bytes[index..]);
        index += self.requestor.as_bytes(&mut bytes[index..]);
        index += self.selection.as_bytes(&mut bytes[index..]);
        index += self.target.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (owner, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (requestor, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (target, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                time,
                owner,
                requestor,
                selection,
                target,
                property,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ClientMessageEvent {
    pub format: Card8,
    pub window: Window,
    pub type_: Atom,
    pub data: ClientMessageData,
}
impl AsByteSequence for ClientMessageEvent {
    #[inline]
    fn size() -> usize {
        <ClientMessageData>::size() + <Atom>::size() + <Window>::size() + <Card8>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.format.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.type_.as_bytes(&mut bytes[index..]);
        index += self.data.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (format, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (type_, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (data, sz): (ClientMessageData, usize) =
            <ClientMessageData>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                format,
                window,
                type_,
                data,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for MapNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.override_redirect.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (override_redirect, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                event,
                window,
                override_redirect,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeyPressEvent {
    pub detail: Keycode,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for KeyPressEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                same_screen,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ConfigureRequestEvent {
    pub stack_mode: Byte,
    pub parent: Window,
    pub window: Window,
    pub sibling: Window,
    pub x: Int16,
    pub y: Int16,
    pub width: Card16,
    pub height: Card16,
    pub border_width: Card16,
    pub value_mask: Card16,
}
impl AsByteSequence for ConfigureRequestEvent {
    #[inline]
    fn size() -> usize {
        <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.stack_mode.as_bytes(&mut bytes[index..]);
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.sibling.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.width.as_bytes(&mut bytes[index..]);
        index += self.height.as_bytes(&mut bytes[index..]);
        index += self.border_width.as_bytes(&mut bytes[index..]);
        index += self.value_mask.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (stack_mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (sibling, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (height, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (border_width, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (value_mask, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                stack_mode,
                parent,
                window,
                sibling,
                x,
                y,
                width,
                height,
                border_width,
                value_mask,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeyRelease {
    pub detail: Keycode,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for KeyRelease {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Keycode>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                same_screen,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct EnterNotifyEvent {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub mode: Byte,
    pub same_screen_focus: Byte,
}
impl AsByteSequence for EnterNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.same_screen_focus.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen_focus, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                mode,
                same_screen_focus,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionNotifyEvent {
    pub time: Timestamp,
    pub requestor: Window,
    pub selection: Atom,
    pub target: Atom,
    pub property: Atom,
}
impl AsByteSequence for SelectionNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size()
            + <Atom>::size()
            + <Atom>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.requestor.as_bytes(&mut bytes[index..]);
        index += self.selection.as_bytes(&mut bytes[index..]);
        index += self.target.as_bytes(&mut bytes[index..]);
        index += self.property.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (requestor, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (target, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        let (property, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                time,
                requestor,
                selection,
                target,
                property,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ColormapNotifyEvent {
    pub window: Window,
    pub colormap: Colormap,
    pub new: ::std::os::raw::c_char,
    pub state: Byte,
}
impl AsByteSequence for ColormapNotifyEvent {
    #[inline]
    fn size() -> usize {
        2 + <Byte>::size()
            + <::std::os::raw::c_char>::size()
            + <Colormap>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.colormap.as_bytes(&mut bytes[index..]);
        index += self.new.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += 2;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (colormap, sz): (Colormap, usize) = <Colormap>::from_bytes(&bytes[index..])?;
        index += sz;
        let (new, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 2;
        Some((
            Self {
                window,
                colormap,
                new,
                state,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct DestroyNotifyEvent {
    pub event: Window,
    pub window: Window,
}
impl AsByteSequence for DestroyNotifyEvent {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { event, window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct SelectionClearEvent {
    pub time: Timestamp,
    pub owner: Window,
    pub selection: Atom,
}
impl AsByteSequence for SelectionClearEvent {
    #[inline]
    fn size() -> usize {
        <Atom>::size() + <Window>::size() + <Timestamp>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.owner.as_bytes(&mut bytes[index..]);
        index += self.selection.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (owner, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (selection, sz): (Atom, usize) = <Atom>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                time,
                owner,
                selection,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct LeaveNotify {
    pub detail: Byte,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub mode: Byte,
    pub same_screen_focus: Byte,
}
impl AsByteSequence for LeaveNotify {
    #[inline]
    fn size() -> usize {
        <Byte>::size()
            + <Byte>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += self.same_screen_focus.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen_focus, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                mode,
                same_screen_focus,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ReparentNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub parent: Window,
    pub x: Int16,
    pub y: Int16,
    pub override_redirect: ::std::os::raw::c_char,
}
impl AsByteSequence for ReparentNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.x.as_bytes(&mut bytes[index..]);
        index += self.y.as_bytes(&mut bytes[index..]);
        index += self.override_redirect.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (override_redirect, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                event,
                window,
                parent,
                x,
                y,
                override_redirect,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct MapRequestEvent {
    pub parent: Window,
    pub window: Window,
}
impl AsByteSequence for MapRequestEvent {
    #[inline]
    fn size() -> usize {
        <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.parent.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (parent, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { parent, window }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct ButtonPressEvent {
    pub detail: Button,
    pub time: Timestamp,
    pub root: Window,
    pub event: Window,
    pub child: Window,
    pub root_x: Int16,
    pub root_y: Int16,
    pub event_x: Int16,
    pub event_y: Int16,
    pub state: Card16,
    pub same_screen: ::std::os::raw::c_char,
}
impl AsByteSequence for ButtonPressEvent {
    #[inline]
    fn size() -> usize {
        1 + <::std::os::raw::c_char>::size()
            + <Card16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Int16>::size()
            + <Window>::size()
            + <Window>::size()
            + <Window>::size()
            + <Timestamp>::size()
            + <Button>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.time.as_bytes(&mut bytes[index..]);
        index += self.root.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.child.as_bytes(&mut bytes[index..]);
        index += self.root_x.as_bytes(&mut bytes[index..]);
        index += self.root_y.as_bytes(&mut bytes[index..]);
        index += self.event_x.as_bytes(&mut bytes[index..]);
        index += self.event_y.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += self.same_screen.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Button, usize) = <Button>::from_bytes(&bytes[index..])?;
        index += sz;
        let (time, sz): (Timestamp, usize) = <Timestamp>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (child, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (root_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_x, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event_y, sz): (Int16, usize) = <Int16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (same_screen, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                detail,
                time,
                root,
                event,
                child,
                root_x,
                root_y,
                event_x,
                event_y,
                state,
                same_screen,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct UnmapNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub from_configure: ::std::os::raw::c_char,
}
impl AsByteSequence for UnmapNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <::std::os::raw::c_char>::size() + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.from_configure.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (from_configure, sz): (::std::os::raw::c_char, usize) =
            <::std::os::raw::c_char>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                event,
                window,
                from_configure,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct CirculateNotifyEvent {
    pub event: Window,
    pub window: Window,
    pub place: Byte,
}
impl AsByteSequence for CirculateNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + 4 + <Window>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.window.as_bytes(&mut bytes[index..]);
        index += 4;
        index += self.place.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 4;
        let (place, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                event,
                window,
                place,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct FocusOut {
    pub detail: Byte,
    pub event: Window,
    pub mode: Byte,
}
impl AsByteSequence for FocusOut {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + <Byte>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.detail.as_bytes(&mut bytes[index..]);
        index += self.event.as_bytes(&mut bytes[index..]);
        index += self.mode.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (detail, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (event, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (mode, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((
            Self {
                detail,
                event,
                mode,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct KeymapNotifyEvent {
    pub keys: [Card8; 31],
}
impl AsByteSequence for KeymapNotifyEvent {
    #[inline]
    fn size() -> usize {
        <[Card8; 31]>::size()
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += self.keys.as_bytes(&mut bytes[index..]);
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        let (keys, sz): ([Card8; 31], usize) = <[Card8; 31]>::from_bytes(&bytes[index..])?;
        index += sz;
        Some((Self { keys }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct VisibilityNotifyEvent {
    pub window: Window,
    pub state: Byte,
}
impl AsByteSequence for VisibilityNotifyEvent {
    #[inline]
    fn size() -> usize {
        3 + <Byte>::size() + <Window>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.window.as_bytes(&mut bytes[index..]);
        index += self.state.as_bytes(&mut bytes[index..]);
        index += 3;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (window, sz): (Window, usize) = <Window>::from_bytes(&bytes[index..])?;
        index += sz;
        let (state, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 3;
        Some((Self { window, state }, index))
    }
}
#[derive(Default, Debug, Clone)]
pub struct MappingNotifyEvent {
    pub request: Byte,
    pub first_keycode: Keycode,
    pub count: Card8,
}
impl AsByteSequence for MappingNotifyEvent {
    #[inline]
    fn size() -> usize {
        1 + <Card8>::size() + <Keycode>::size() + <Byte>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.request.as_bytes(&mut bytes[index..]);
        index += self.first_keycode.as_bytes(&mut bytes[index..]);
        index += self.count.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (request, sz): (Byte, usize) = <Byte>::from_bytes(&bytes[index..])?;
        index += sz;
        let (first_keycode, sz): (Keycode, usize) = <Keycode>::from_bytes(&bytes[index..])?;
        index += sz;
        let (count, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                request,
                first_keycode,
                count,
            },
            index,
        ))
    }
}
#[derive(Default, Debug, Clone)]
pub struct NoExposureEvent {
    pub drawable: Drawable,
    pub minor_opcode: Card16,
    pub major_opcode: Card8,
}
impl AsByteSequence for NoExposureEvent {
    #[inline]
    fn size() -> usize {
        1 + <Card8>::size() + <Card16>::size() + <Drawable>::size() + 1
    }
    #[inline]
    fn as_bytes(&self, bytes: &mut [u8]) -> usize {
        let mut index = 0;
        index += 1;
        index += self.drawable.as_bytes(&mut bytes[index..]);
        index += self.minor_opcode.as_bytes(&mut bytes[index..]);
        index += self.major_opcode.as_bytes(&mut bytes[index..]);
        index += 1;
        index
    }
    #[inline]
    fn from_bytes(bytes: &[u8]) -> Option<(Self, usize)> {
        let mut index = 0;
        index += 1;
        let (drawable, sz): (Drawable, usize) = <Drawable>::from_bytes(&bytes[index..])?;
        index += sz;
        let (minor_opcode, sz): (Card16, usize) = <Card16>::from_bytes(&bytes[index..])?;
        index += sz;
        let (major_opcode, sz): (Card8, usize) = <Card8>::from_bytes(&bytes[index..])?;
        index += sz;
        index += 1;
        Some((
            Self {
                drawable,
                minor_opcode,
                major_opcode,
            },
            index,
        ))
    }
}
